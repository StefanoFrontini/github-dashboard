export default [
  {
    sha: "a5b20ada902834040f4bf6604ccd3ff74fd06ec0",
    filename:
      "packages/react-reconciler/src/__tests__/DebugTracing-test.internal.js",
    status: "modified",
    additions: 5,
    deletions: 4,
    changes: 9,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FDebugTracing-test.internal.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FDebugTracing-test.internal.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FDebugTracing-test.internal.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -12,7 +12,7 @@\n describe('DebugTracing', () => {\n   let React;\n   let ReactTestRenderer;\n-  let Scheduler;\n+  let waitForPaint;\n \n   let logs;\n \n@@ -27,7 +27,8 @@ describe('DebugTracing', () => {\n \n     React = require('react');\n     ReactTestRenderer = require('react-test-renderer');\n-    Scheduler = require('scheduler');\n+    const InternalTestUtils = require('internal-test-utils');\n+    waitForPaint = InternalTestUtils.waitForPaint;\n \n     logs = [];\n \n@@ -100,7 +101,7 @@ describe('DebugTracing', () => {\n   });\n \n   // @gate experimental && build === 'development' && enableDebugTracing && enableCPUSuspense\n-  it('should log sync render with CPU suspense', () => {\n+  it('should log sync render with CPU suspense', async () => {\n     function Example() {\n       console.log('<Example/>');\n       return null;\n@@ -129,7 +130,7 @@ describe('DebugTracing', () => {\n \n     logs.splice(0);\n \n-    expect(Scheduler).toFlushUntilNextPaint([]);\n+    await waitForPaint([]);\n \n     expect(logs).toEqual([\n       `group: ⚛️ render (${RETRY_LANE_STRING})`,",
  },
  {
    sha: "15248976ca1bfe2da0549ce065c17ea3853d93b8",
    filename:
      "packages/react-reconciler/src/__tests__/ReactActWarnings-test.js",
    status: "modified",
    additions: 37,
    deletions: 31,
    changes: 68,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactActWarnings-test.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactActWarnings-test.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactActWarnings-test.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -9,6 +9,8 @@\n \n let React;\n let Scheduler;\n+let waitForAll;\n+let assertLog;\n let ReactNoop;\n let useState;\n let act;\n@@ -32,6 +34,10 @@ describe('act warnings', () => {\n     startTransition = React.startTransition;\n     getCacheForType = React.unstable_getCacheForType;\n     caches = [];\n+\n+    const InternalTestUtils = require('internal-test-utils');\n+    waitForAll = InternalTestUtils.waitForAll;\n+    assertLog = InternalTestUtils.assertLog;\n   });\n \n   function createTextCache() {\n@@ -134,17 +140,17 @@ describe('act warnings', () => {\n     }\n   }\n \n-  function withActEnvironment(value, scope) {\n+  async function withActEnvironment(value, scope) {\n     const prevValue = global.IS_REACT_ACT_ENVIRONMENT;\n     global.IS_REACT_ACT_ENVIRONMENT = value;\n     try {\n-      return scope();\n+      return await scope();\n     } finally {\n       global.IS_REACT_ACT_ENVIRONMENT = prevValue;\n     }\n   }\n \n-  test('warns about unwrapped updates only if environment flag is enabled', () => {\n+  test('warns about unwrapped updates only if environment flag is enabled', async () => {\n     let setState;\n     function App() {\n       const [state, _setState] = useState(0);\n@@ -154,34 +160,34 @@ describe('act warnings', () => {\n \n     const root = ReactNoop.createRoot();\n     root.render(<App />);\n-    expect(Scheduler).toFlushAndYield([0]);\n+    await waitForAll([0]);\n     expect(root).toMatchRenderedOutput('0');\n \n     // Default behavior. Flag is undefined. No warning.\n     expect(global.IS_REACT_ACT_ENVIRONMENT).toBe(undefined);\n     setState(1);\n-    expect(Scheduler).toFlushAndYield([1]);\n+    await waitForAll([1]);\n     expect(root).toMatchRenderedOutput('1');\n \n     // Flag is true. Warn.\n-    withActEnvironment(true, () => {\n+    await withActEnvironment(true, async () => {\n       expect(() => setState(2)).toErrorDev(\n         'An update to App inside a test was not wrapped in act',\n       );\n-      expect(Scheduler).toFlushAndYield([2]);\n+      await waitForAll([2]);\n       expect(root).toMatchRenderedOutput('2');\n     });\n \n     // Flag is false. No warning.\n-    withActEnvironment(false, () => {\n+    await withActEnvironment(false, async () => {\n       setState(3);\n-      expect(Scheduler).toFlushAndYield([3]);\n+      await waitForAll([3]);\n       expect(root).toMatchRenderedOutput('3');\n     });\n   });\n \n   // @gate __DEV__\n-  test('act warns if the environment flag is not enabled', () => {\n+  test('act warns if the environment flag is not enabled', async () => {\n     let setState;\n     function App() {\n       const [state, _setState] = useState(0);\n@@ -191,7 +197,7 @@ describe('act warnings', () => {\n \n     const root = ReactNoop.createRoot();\n     root.render(<App />);\n-    expect(Scheduler).toFlushAndYield([0]);\n+    await waitForAll([0]);\n     expect(root).toMatchRenderedOutput('0');\n \n     // Default behavior. Flag is undefined. Warn.\n@@ -204,20 +210,20 @@ describe('act warnings', () => {\n       'The current testing environment is not configured to support act(...)',\n       {withoutStack: true},\n     );\n-    expect(Scheduler).toHaveYielded([1]);\n+    assertLog([1]);\n     expect(root).toMatchRenderedOutput('1');\n \n     // Flag is true. Don't warn.\n-    withActEnvironment(true, () => {\n+    await withActEnvironment(true, () => {\n       act(() => {\n         setState(2);\n       });\n-      expect(Scheduler).toHaveYielded([2]);\n+      assertLog([2]);\n       expect(root).toMatchRenderedOutput('2');\n     });\n \n     // Flag is false. Warn.\n-    withActEnvironment(false, () => {\n+    await withActEnvironment(false, () => {\n       expect(() => {\n         act(() => {\n           setState(1);\n@@ -226,13 +232,13 @@ describe('act warnings', () => {\n         'The current testing environment is not configured to support act(...)',\n         {withoutStack: true},\n       );\n-      expect(Scheduler).toHaveYielded([1]);\n+      assertLog([1]);\n       expect(root).toMatchRenderedOutput('1');\n     });\n   });\n \n-  test('warns if root update is not wrapped', () => {\n-    withActEnvironment(true, () => {\n+  test('warns if root update is not wrapped', async () => {\n+    await withActEnvironment(true, () => {\n       const root = ReactNoop.createRoot();\n       expect(() => root.render('Hi')).toErrorDev(\n         // TODO: Better error message that doesn't make it look like \"Root\" is\n@@ -244,7 +250,7 @@ describe('act warnings', () => {\n   });\n \n   // @gate __DEV__\n-  test('warns if class update is not wrapped', () => {\n+  test('warns if class update is not wrapped', async () => {\n     let app;\n     class App extends React.Component {\n       state = {count: 0};\n@@ -254,7 +260,7 @@ describe('act warnings', () => {\n       }\n     }\n \n-    withActEnvironment(true, () => {\n+    await withActEnvironment(true, () => {\n       const root = ReactNoop.createRoot();\n       act(() => {\n         root.render(<App />);\n@@ -266,18 +272,18 @@ describe('act warnings', () => {\n   });\n \n   // @gate __DEV__\n-  test('warns even if update is synchronous', () => {\n+  test('warns even if update is synchronous', async () => {\n     let setState;\n     function App() {\n       const [state, _setState] = useState(0);\n       setState = _setState;\n       return <Text text={state} />;\n     }\n \n-    withActEnvironment(true, () => {\n+    await withActEnvironment(true, () => {\n       const root = ReactNoop.createRoot();\n       act(() => root.render(<App />));\n-      expect(Scheduler).toHaveYielded([0]);\n+      assertLog([0]);\n       expect(root).toMatchRenderedOutput('0');\n \n       // Even though this update is synchronous, we should still fire a warning,\n@@ -286,14 +292,14 @@ describe('act warnings', () => {\n         'An update to App inside a test was not wrapped in act(...)',\n       );\n \n-      expect(Scheduler).toHaveYielded([1]);\n+      assertLog([1]);\n       expect(root).toMatchRenderedOutput('1');\n     });\n   });\n \n   // @gate __DEV__\n   // @gate enableLegacyCache\n-  test('warns if Suspense retry is not wrapped', () => {\n+  test('warns if Suspense retry is not wrapped', async () => {\n     function App() {\n       return (\n         <Suspense fallback={<Text text=\"Loading...\" />}>\n@@ -302,12 +308,12 @@ describe('act warnings', () => {\n       );\n     }\n \n-    withActEnvironment(true, () => {\n+    await withActEnvironment(true, () => {\n       const root = ReactNoop.createRoot();\n       act(() => {\n         root.render(<App />);\n       });\n-      expect(Scheduler).toHaveYielded(['Suspend! [Async]', 'Loading...']);\n+      assertLog(['Suspend! [Async]', 'Loading...']);\n       expect(root).toMatchRenderedOutput('Loading...');\n \n       // This is a retry, not a ping, because we already showed a fallback.\n@@ -321,7 +327,7 @@ describe('act warnings', () => {\n \n   // @gate __DEV__\n   // @gate enableLegacyCache\n-  test('warns if Suspense ping is not wrapped', () => {\n+  test('warns if Suspense ping is not wrapped', async () => {\n     function App({showMore}) {\n       return (\n         <Suspense fallback={<Text text=\"Loading...\" />}>\n@@ -330,20 +336,20 @@ describe('act warnings', () => {\n       );\n     }\n \n-    withActEnvironment(true, () => {\n+    await withActEnvironment(true, () => {\n       const root = ReactNoop.createRoot();\n       act(() => {\n         root.render(<App showMore={false} />);\n       });\n-      expect(Scheduler).toHaveYielded(['(empty)']);\n+      assertLog(['(empty)']);\n       expect(root).toMatchRenderedOutput('(empty)');\n \n       act(() => {\n         startTransition(() => {\n           root.render(<App showMore={true} />);\n         });\n       });\n-      expect(Scheduler).toHaveYielded(['Suspend! [Async]', 'Loading...']);\n+      assertLog(['Suspend! [Async]', 'Loading...']);\n       expect(root).toMatchRenderedOutput('(empty)');\n \n       // This is a ping, not a retry, because no fallback is showing.",
  },
  {
    sha: "55c3b2162a57c639e2fa07380f2995f5c90f1928",
    filename:
      "packages/react-reconciler/src/__tests__/ReactBatching-test.internal.js",
    status: "modified",
    additions: 19,
    deletions: 17,
    changes: 36,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactBatching-test.internal.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactBatching-test.internal.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactBatching-test.internal.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -2,6 +2,8 @@ let React;\n let ReactFeatureFlags;\n let ReactNoop;\n let Scheduler;\n+let waitForAll;\n+let assertLog;\n let ReactCache;\n let Suspense;\n let TextResource;\n@@ -18,6 +20,10 @@ describe('ReactBlockingMode', () => {\n     ReactCache = require('react-cache');\n     Suspense = React.Suspense;\n \n+    const InternalTestUtils = require('internal-test-utils');\n+    waitForAll = InternalTestUtils.waitForAll;\n+    assertLog = InternalTestUtils.assertLog;\n+\n     TextResource = ReactCache.unstable_createResource(\n       ([text, ms = 0]) => {\n         return new Promise((resolve, reject) =>\n@@ -52,7 +58,7 @@ describe('ReactBlockingMode', () => {\n     }\n   }\n \n-  it('updates flush without yielding in the next event', () => {\n+  it('updates flush without yielding in the next event', async () => {\n     const root = ReactNoop.createRoot();\n \n     root.render(\n@@ -66,12 +72,11 @@ describe('ReactBlockingMode', () => {\n     // Nothing should have rendered yet\n     expect(root).toMatchRenderedOutput(null);\n \n-    // Everything should render immediately in the next event\n-    expect(Scheduler).toFlushAndYield(['A', 'B', 'C']);\n+    await waitForAll(['A', 'B', 'C']);\n     expect(root).toMatchRenderedOutput('ABC');\n   });\n \n-  it('layout updates flush synchronously in same event', () => {\n+  it('layout updates flush synchronously in same event', async () => {\n     const {useLayoutEffect} = React;\n \n     function App() {\n@@ -84,9 +89,9 @@ describe('ReactBlockingMode', () => {\n     const root = ReactNoop.createRoot();\n     root.render(<App />);\n     expect(root).toMatchRenderedOutput(null);\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n \n-    expect(Scheduler).toFlushAndYield(['Hi', 'Layout effect']);\n+    await waitForAll(['Hi', 'Layout effect']);\n     expect(root).toMatchRenderedOutput('Hi');\n   });\n \n@@ -106,15 +111,15 @@ describe('ReactBlockingMode', () => {\n       </Suspense>,\n     );\n \n-    expect(Scheduler).toFlushAndYield(['A', 'Suspend! [B]', 'C', 'Loading...']);\n+    await waitForAll(['A', 'Suspend! [B]', 'C', 'Loading...']);\n     // In Legacy Mode, A and B would mount in a hidden primary tree. In\n     // Concurrent Mode, nothing in the primary tree should mount. But the\n     // fallback should mount immediately.\n     expect(root).toMatchRenderedOutput('Loading...');\n \n     await jest.advanceTimersByTime(1000);\n-    expect(Scheduler).toHaveYielded(['Promise resolved [B]']);\n-    expect(Scheduler).toFlushAndYield(['A', 'B', 'C']);\n+    assertLog(['Promise resolved [B]']);\n+    await waitForAll(['A', 'B', 'C']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         <span>A</span>\n@@ -124,7 +129,7 @@ describe('ReactBlockingMode', () => {\n     );\n   });\n \n-  it('flushSync does not flush batched work', () => {\n+  it('flushSync does not flush batched work', async () => {\n     const {useState, forwardRef, useImperativeHandle} = React;\n     const root = ReactNoop.createRoot();\n \n@@ -143,8 +148,7 @@ describe('ReactBlockingMode', () => {\n       </>,\n     );\n \n-    // Mount\n-    expect(Scheduler).toFlushAndYield(['A0', 'B0']);\n+    await waitForAll(['A0', 'B0']);\n     expect(root).toMatchRenderedOutput('A0B0');\n \n     // Schedule a batched update to the first sibling\n@@ -159,15 +163,13 @@ describe('ReactBlockingMode', () => {\n \n     // Now flush the first update\n     if (gate(flags => flags.enableUnifiedSyncLane)) {\n-      expect(Scheduler).toHaveYielded(['A1', 'B1']);\n+      assertLog(['A1', 'B1']);\n       expect(root).toMatchRenderedOutput('A1B1');\n     } else {\n-      // Only the second update should have flushed synchronously\n-      expect(Scheduler).toHaveYielded(['B1']);\n+      assertLog(['B1']);\n       expect(root).toMatchRenderedOutput('A0B1');\n \n-      // Now flush the first update\n-      expect(Scheduler).toFlushAndYield(['A1']);\n+      await waitForAll(['A1']);\n       expect(root).toMatchRenderedOutput('A1B1');\n     }\n   });",
  },
  {
    sha: "ec6d9d619078ffee4ca24355e979d29db0a3fad5",
    filename:
      "packages/react-reconciler/src/__tests__/ReactCPUSuspense-test.js",
    status: "modified",
    additions: 15,
    deletions: 19,
    changes: 34,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactCPUSuspense-test.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactCPUSuspense-test.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactCPUSuspense-test.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -10,6 +10,9 @@ let readText;\n let resolveText;\n // let rejectText;\n \n+let assertLog;\n+let waitForPaint;\n+\n describe('ReactSuspenseWithNoopRenderer', () => {\n   beforeEach(() => {\n     jest.resetModules();\n@@ -21,6 +24,10 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     Suspense = React.Suspense;\n     useState = React.useState;\n \n+    const InternalTestUtils = require('internal-test-utils');\n+    assertLog = InternalTestUtils.assertLog;\n+    waitForPaint = InternalTestUtils.waitForPaint;\n+\n     textCache = new Map();\n \n     readText = text => {\n@@ -128,16 +135,15 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     const root = ReactNoop.createRoot();\n     await act(async () => {\n       root.render(<App />);\n-      expect(Scheduler).toFlushUntilNextPaint(['Outer', 'Loading...']);\n+      await waitForPaint(['Outer', 'Loading...']);\n       expect(root).toMatchRenderedOutput(\n         <>\n           Outer\n           <div>Loading...</div>\n         </>,\n       );\n     });\n-    // Inner contents finish in separate commit from outer\n-    expect(Scheduler).toHaveYielded(['Inner']);\n+    assertLog(['Inner']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         Outer\n@@ -172,8 +178,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    // Inner contents finish in separate commit from outer\n-    expect(Scheduler).toHaveYielded(['Outer', 'Loading...', 'Inner [0]']);\n+    assertLog(['Outer', 'Loading...', 'Inner [0]']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         Outer\n@@ -185,8 +190,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     await act(async () => {\n       setCount(1);\n     });\n-    // Entire update finishes in a single commit\n-    expect(Scheduler).toHaveYielded(['Outer', 'Inner [1]']);\n+    assertLog(['Outer', 'Inner [1]']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         Outer\n@@ -215,16 +219,15 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     const root = ReactNoop.createRoot();\n     await act(async () => {\n       root.render(<App />);\n-      expect(Scheduler).toFlushUntilNextPaint(['Outer', 'Loading...']);\n+      await waitForPaint(['Outer', 'Loading...']);\n       expect(root).toMatchRenderedOutput(\n         <>\n           Outer\n           <div>Loading...</div>\n         </>,\n       );\n     });\n-    // Inner contents suspended, so we continue showing a fallback.\n-    expect(Scheduler).toHaveYielded(['Suspend! [Inner]']);\n+    assertLog(['Suspend! [Inner]']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         Outer\n@@ -236,7 +239,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     await act(async () => {\n       await resolveText('Inner');\n     });\n-    expect(Scheduler).toHaveYielded(['Inner']);\n+    assertLog(['Inner']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         Outer\n@@ -273,14 +276,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    // Each level commits separately\n-    expect(Scheduler).toHaveYielded([\n-      'A',\n-      'Loading B...',\n-      'B',\n-      'Loading C...',\n-      'C',\n-    ]);\n+    assertLog(['A', 'Loading B...', 'B', 'Loading C...', 'C']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         A",
  },
  {
    sha: "47a96971261fdda087de069ff9a340ff33a9d9bb",
    filename: "packages/react-reconciler/src/__tests__/ReactCache-test.js",
    status: "modified",
    additions: 108,
    deletions: 170,
    changes: 278,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactCache-test.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactCache-test.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactCache-test.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -3,6 +3,7 @@ let ReactNoop;\n let Cache;\n let getCacheSignal;\n let Scheduler;\n+let assertLog;\n let act;\n let Suspense;\n let Offscreen;\n@@ -32,6 +33,9 @@ describe('ReactCache', () => {\n     startTransition = React.startTransition;\n     useState = React.useState;\n \n+    const InternalTestUtils = require('internal-test-utils');\n+    assertLog = InternalTestUtils.assertLog;\n+\n     textCaches = [];\n     seededCache = null;\n \n@@ -203,20 +207,19 @@ describe('ReactCache', () => {\n         </Cache>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);\n+    assertLog(['Cache miss! [A]', 'Loading...']);\n     expect(root).toMatchRenderedOutput('Loading...');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded(['A']);\n+    assertLog(['A']);\n     expect(root).toMatchRenderedOutput('A');\n \n     await act(async () => {\n       root.render('Bye');\n     });\n-    // no cleanup: cache is still retained at the root\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(root).toMatchRenderedOutput('Bye');\n   });\n \n@@ -230,20 +233,19 @@ describe('ReactCache', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);\n+    assertLog(['Cache miss! [A]', 'Loading...']);\n     expect(root).toMatchRenderedOutput('Loading...');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded(['A']);\n+    assertLog(['A']);\n     expect(root).toMatchRenderedOutput('A');\n \n     await act(async () => {\n       root.render('Bye');\n     });\n-    // no cleanup: cache is still retained at the root\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(root).toMatchRenderedOutput('Bye');\n   });\n \n@@ -271,26 +273,19 @@ describe('ReactCache', () => {\n       root.render(<App showMore={false} />);\n     });\n \n-    // Even though there are two new <Cache /> trees, they should share the same\n-    // data cache. So there should be only a single cache miss for A.\n-    expect(Scheduler).toHaveYielded([\n-      'Cache miss! [A]',\n-      'Loading...',\n-      'Loading...',\n-    ]);\n+    assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);\n     expect(root).toMatchRenderedOutput('Loading...Loading...');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded(['A', 'A']);\n+    assertLog(['A', 'A']);\n     expect(root).toMatchRenderedOutput('AA');\n \n     await act(async () => {\n       root.render('Bye');\n     });\n-    // no cleanup: cache is still retained at the root\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(root).toMatchRenderedOutput('Bye');\n   });\n \n@@ -319,34 +314,25 @@ describe('ReactCache', () => {\n     await act(async () => {\n       root.render(<App showMore={false} />);\n     });\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(root).toMatchRenderedOutput('(empty)');\n \n     await act(async () => {\n       root.render(<App showMore={true} />);\n     });\n-    // Even though there are two new <Cache /> trees, they should share the same\n-    // data cache. So there should be only a single cache miss for A.\n-    expect(Scheduler).toHaveYielded([\n-      'Cache miss! [A]',\n-      'Loading...',\n-      'Loading...',\n-    ]);\n+    assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);\n     expect(root).toMatchRenderedOutput('Loading...Loading...');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded(['A', 'A']);\n+    assertLog(['A', 'A']);\n     expect(root).toMatchRenderedOutput('AA');\n \n     await act(async () => {\n       root.render('Bye');\n     });\n-    // cleanup occurs for the cache shared by the inner cache boundaries (which\n-    // are not shared w the root because they were added in an update)\n-    // note that no cache is created for the root since the cache is never accessed\n-    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v1]']);\n+    assertLog(['Cache cleanup: A [v1]']);\n     expect(root).toMatchRenderedOutput('Bye');\n   });\n \n@@ -370,22 +356,19 @@ describe('ReactCache', () => {\n       await act(async () => {\n         root.render(<App />);\n       });\n-      // Even though there is a nested <Cache /> boundary, it should share the same\n-      // data cache as the root. So there should be only a single cache miss for A.\n-      expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);\n+      assertLog(['Cache miss! [A]', 'Loading...']);\n       expect(root).toMatchRenderedOutput('Loading...');\n \n       await act(async () => {\n         resolveMostRecentTextCache('A');\n       });\n-      expect(Scheduler).toHaveYielded(['A', 'A']);\n+      assertLog(['A', 'A']);\n       expect(root).toMatchRenderedOutput('AA');\n \n       await act(async () => {\n         root.render('Bye');\n       });\n-      // no cleanup: cache is still retained at the root\n-      expect(Scheduler).toHaveYielded([]);\n+      assertLog([]);\n       expect(root).toMatchRenderedOutput('Bye');\n     },\n   );\n@@ -412,14 +395,14 @@ describe('ReactCache', () => {\n       seedNextTextCache('A');\n       root.render(<App showMore={false} />);\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]']);\n+    assertLog(['A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     // Add a new cache boundary\n     await act(async () => {\n       root.render(<App showMore={true} />);\n     });\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       'A [v1]',\n       // New tree should use already cached data\n       'A [v1]',\n@@ -429,8 +412,7 @@ describe('ReactCache', () => {\n     await act(async () => {\n       root.render('Bye');\n     });\n-    // no cleanup: cache is still retained at the root\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(root).toMatchRenderedOutput('Bye');\n   });\n \n@@ -460,14 +442,14 @@ describe('ReactCache', () => {\n       seedNextTextCache('A');\n       root.render(<App showMore={false} />);\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]']);\n+    assertLog(['A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     // Add a new cache boundary\n     await act(async () => {\n       root.render(<App showMore={true} />);\n     });\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       'A [v1]',\n       // New tree should load fresh data.\n       'Cache miss! [A]',\n@@ -477,7 +459,7 @@ describe('ReactCache', () => {\n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded(['A [v2]']);\n+    assertLog(['A [v2]']);\n     expect(root).toMatchRenderedOutput('A [v1]A [v2]');\n \n     // Replace all the children: this should retain the root Cache instance,\n@@ -486,9 +468,7 @@ describe('ReactCache', () => {\n     await act(async () => {\n       root.render('Bye!');\n     });\n-    // Cleanup occurs for the *second* cache instance: the first is still\n-    // referenced by the root\n-    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v2]']);\n+    assertLog(['Cache cleanup: A [v2]']);\n     expect(root).toMatchRenderedOutput('Bye!');\n   });\n \n@@ -535,13 +515,13 @@ describe('ReactCache', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading shell...']);\n+    assertLog(['Cache miss! [A]', 'Loading shell...']);\n     expect(root).toMatchRenderedOutput('Loading shell...');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       'Shell',\n       // There's a cache miss for B, because it hasn't been read yet. But not\n       // A, because it was cached when we rendered the shell.\n@@ -558,7 +538,7 @@ describe('ReactCache', () => {\n     await act(async () => {\n       resolveMostRecentTextCache('B');\n     });\n-    expect(Scheduler).toHaveYielded(['Content']);\n+    assertLog(['Content']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         <div>Shell</div>\n@@ -569,8 +549,7 @@ describe('ReactCache', () => {\n     await act(async () => {\n       root.render('Bye');\n     });\n-    // no cleanup: cache is still retained at the root\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(root).toMatchRenderedOutput('Bye');\n   });\n \n@@ -619,19 +598,19 @@ describe('ReactCache', () => {\n     await act(async () => {\n       root.render(<App showMore={false} />);\n     });\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(root).toMatchRenderedOutput('(empty)');\n \n     await act(async () => {\n       root.render(<App showMore={true} />);\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading shell...']);\n+    assertLog(['Cache miss! [A]', 'Loading shell...']);\n     expect(root).toMatchRenderedOutput('Loading shell...');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       'Shell',\n       // There's a cache miss for B, because it hasn't been read yet. But not\n       // A, because it was cached when we rendered the shell.\n@@ -648,7 +627,7 @@ describe('ReactCache', () => {\n     await act(async () => {\n       resolveMostRecentTextCache('B');\n     });\n-    expect(Scheduler).toHaveYielded(['Content']);\n+    assertLog(['Content']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         <div>Shell</div>\n@@ -659,10 +638,7 @@ describe('ReactCache', () => {\n     await act(async () => {\n       root.render('Bye');\n     });\n-    expect(Scheduler).toHaveYielded([\n-      'Cache cleanup: A [v1]',\n-      'Cache cleanup: B [v1]',\n-    ]);\n+    assertLog(['Cache cleanup: A [v1]', 'Cache cleanup: B [v1]']);\n     expect(root).toMatchRenderedOutput('Bye');\n   });\n \n@@ -683,30 +659,30 @@ describe('ReactCache', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);\n+    assertLog(['Cache miss! [A]', 'Loading...']);\n     expect(root).toMatchRenderedOutput('Loading...');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]']);\n+    assertLog(['A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     // Refresh for new data.\n     await act(async () => {\n       startTransition(() => refresh());\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);\n+    assertLog(['Cache miss! [A]', 'Loading...']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n     // Note that the version has updated\n     if (getCacheSignal) {\n-      expect(Scheduler).toHaveYielded(['A [v2]', 'Cache cleanup: A [v1]']);\n+      assertLog(['A [v2]', 'Cache cleanup: A [v1]']);\n     } else {\n-      expect(Scheduler).toHaveYielded(['A [v2]']);\n+      assertLog(['A [v2]']);\n     }\n     expect(root).toMatchRenderedOutput('A [v2]');\n \n@@ -733,34 +709,32 @@ describe('ReactCache', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);\n+    assertLog(['Cache miss! [A]', 'Loading...']);\n     expect(root).toMatchRenderedOutput('Loading...');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]']);\n+    assertLog(['A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     // Refresh for new data.\n     await act(async () => {\n       startTransition(() => refresh());\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);\n+    assertLog(['Cache miss! [A]', 'Loading...']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    // Note that the version has updated, and the previous cache is cleared\n-    expect(Scheduler).toHaveYielded(['A [v2]', 'Cache cleanup: A [v1]']);\n+    assertLog(['A [v2]', 'Cache cleanup: A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v2]');\n \n     await act(async () => {\n       root.render('Bye');\n     });\n-    // the original root cache already cleaned up when the refresh completed\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(root).toMatchRenderedOutput('Bye');\n   });\n \n@@ -781,20 +755,20 @@ describe('ReactCache', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);\n+    assertLog(['Cache miss! [A]', 'Loading...']);\n     expect(root).toMatchRenderedOutput('Loading...');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]']);\n+    assertLog(['A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     // Refresh for new data.\n     await act(async () => {\n       refresh();\n     });\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       'Cache miss! [A]',\n       'Loading...',\n       // The v1 cache can be cleaned up since everything that references it has\n@@ -807,15 +781,13 @@ describe('ReactCache', () => {\n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    // Note that the version has updated, and the previous cache is cleared\n-    expect(Scheduler).toHaveYielded(['A [v2]']);\n+    assertLog(['A [v2]']);\n     expect(root).toMatchRenderedOutput('A [v2]');\n \n     await act(async () => {\n       root.render('Bye');\n     });\n-    // the original root cache already cleaned up when the refresh completed\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(root).toMatchRenderedOutput('Bye');\n   });\n \n@@ -847,13 +819,13 @@ describe('ReactCache', () => {\n         </Cache>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);\n+    assertLog(['Cache miss! [A]', 'Loading...']);\n     expect(root).toMatchRenderedOutput('Loading...');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]']);\n+    assertLog(['A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     // Refresh for new data.\n@@ -869,16 +841,13 @@ describe('ReactCache', () => {\n         }),\n       );\n     });\n-    // The root should re-render without a cache miss.\n-    // The cache is not cleared up yet, since it's still reference by the root\n-    expect(Scheduler).toHaveYielded(['A [v2]']);\n+    assertLog(['A [v2]']);\n     expect(root).toMatchRenderedOutput('A [v2]');\n \n     await act(async () => {\n       root.render('Bye');\n     });\n-    // the refreshed cache boundary is unmounted and cleans up\n-    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v2]']);\n+    assertLog(['Cache cleanup: A [v2]']);\n     expect(root).toMatchRenderedOutput('Bye');\n   });\n \n@@ -913,15 +882,15 @@ describe('ReactCache', () => {\n       seedNextTextCache('A');\n       root.render(<App showMore={false} />);\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]']);\n+    assertLog(['A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     // Add a new cache boundary\n     await act(async () => {\n       seedNextTextCache('A');\n       root.render(<App showMore={true} />);\n     });\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       'A [v1]',\n       // New tree should load fresh data.\n       'A [v2]',\n@@ -933,17 +902,13 @@ describe('ReactCache', () => {\n     await act(async () => {\n       startTransition(() => refreshShell());\n     });\n-    expect(Scheduler).toHaveYielded([\n-      'Cache miss! [A]',\n-      'Loading...',\n-      'Loading...',\n-    ]);\n+    assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);\n     expect(root).toMatchRenderedOutput('A [v1]A [v2]');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       'A [v3]',\n       'A [v3]',\n       // once the refresh completes the inner showMore boundary frees its previous\n@@ -955,9 +920,7 @@ describe('ReactCache', () => {\n     await act(async () => {\n       root.render('Bye!');\n     });\n-    // Unmounting children releases the refreshed cache instance only; the root\n-    // still retains the original cache instance used for the first render\n-    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v3]']);\n+    assertLog(['Cache cleanup: A [v3]']);\n     expect(root).toMatchRenderedOutput('Bye!');\n   });\n \n@@ -1004,32 +967,26 @@ describe('ReactCache', () => {\n         root.render(<App showMore={true} />);\n       });\n \n-      // Even though there are two new <Cache /> trees, they should share the same\n-      // data cache. So there should be only a single cache miss for A.\n-      expect(Scheduler).toHaveYielded([\n-        'Cache miss! [A]',\n-        'Loading...',\n-        'Loading...',\n-      ]);\n+      assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);\n       expect(root).toMatchRenderedOutput('Loading...Loading...');\n \n       await act(async () => {\n         resolveMostRecentTextCache('A');\n       });\n-      expect(Scheduler).toHaveYielded(['A [v1]', 'A [v1]']);\n+      assertLog(['A [v1]', 'A [v1]']);\n       expect(root).toMatchRenderedOutput('A [v1]A [v1]');\n \n       // Refresh the first boundary. It should not refresh the second boundary,\n       // even though they previously shared the same underlying cache.\n       await act(async () => {\n         await refreshFirstBoundary();\n       });\n-      expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);\n+      assertLog(['Cache miss! [A]', 'Loading...']);\n \n       await act(async () => {\n         resolveMostRecentTextCache('A');\n       });\n-      expect(Scheduler).toHaveYielded(['A [v2]']);\n+      assertLog(['A [v2]']);\n       expect(root).toMatchRenderedOutput('A [v2]A [v1]');\n \n       // Unmount children: this should clear *both* cache instances:\n@@ -1041,10 +998,7 @@ describe('ReactCache', () => {\n       await act(async () => {\n         root.render('Bye!');\n       });\n-      expect(Scheduler).toHaveYielded([\n-        'Cache cleanup: A [v2]',\n-        'Cache cleanup: A [v1]',\n-      ]);\n+      assertLog(['Cache cleanup: A [v2]', 'Cache cleanup: A [v1]']);\n       expect(root).toMatchRenderedOutput('Bye!');\n     },\n   );\n@@ -1079,11 +1033,7 @@ describe('ReactCache', () => {\n       await act(async () => {\n         root.render(<App showMore={false} />);\n       });\n-      expect(Scheduler).toHaveYielded([\n-        'Cache miss! [A]',\n-        'Cache miss! [B]',\n-        'Loading...',\n-      ]);\n+      assertLog(['Cache miss! [A]', 'Cache miss! [B]', 'Loading...']);\n       expect(root).toMatchRenderedOutput('Loading...');\n \n       await act(async () => {\n@@ -1093,7 +1043,7 @@ describe('ReactCache', () => {\n         // And mount the second tree, which includes new content\n         root.render(<App showMore={true} />);\n       });\n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         // The new tree should use a fresh cache\n         'Cache miss! [A]',\n         'Loading...',\n@@ -1108,16 +1058,13 @@ describe('ReactCache', () => {\n       await act(async () => {\n         resolveMostRecentTextCache('A');\n       });\n-      expect(Scheduler).toHaveYielded(['A [v2]']);\n+      assertLog(['A [v2]']);\n       expect(root).toMatchRenderedOutput('A [v2] A [v1] B [v1]');\n \n       await act(async () => {\n         root.render('Bye!');\n       });\n-      // Unmounting children releases both cache boundaries, but the original\n-      // cache instance (used by second boundary) is still referenced by the root.\n-      // only the second cache instance is freed.\n-      expect(Scheduler).toHaveYielded(['Cache cleanup: A [v2]']);\n+      assertLog(['Cache cleanup: A [v2]']);\n       expect(root).toMatchRenderedOutput('Bye!');\n     },\n   );\n@@ -1138,7 +1085,7 @@ describe('ReactCache', () => {\n         <Suspense fallback={<Text text=\"Loading...\" />}>(empty)</Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(root).toMatchRenderedOutput('(empty)');\n \n     await act(async () => {\n@@ -1150,7 +1097,7 @@ describe('ReactCache', () => {\n         );\n       });\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);\n+    assertLog(['Cache miss! [A]', 'Loading...']);\n     expect(root).toMatchRenderedOutput('(empty)');\n \n     await act(async () => {\n@@ -1163,7 +1110,7 @@ describe('ReactCache', () => {\n         );\n       });\n     });\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       // No cache miss, because it uses the pooled cache\n       'Loading...',\n     ]);\n@@ -1173,7 +1120,7 @@ describe('ReactCache', () => {\n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]', 'A [v1]']);\n+    assertLog(['A [v1]', 'A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]A [v1]');\n \n     // Now do another transition\n@@ -1188,7 +1135,7 @@ describe('ReactCache', () => {\n         );\n       });\n     });\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       // First two children use the old cache because they already finished\n       'A [v1]',\n       'A [v1]',\n@@ -1201,7 +1148,7 @@ describe('ReactCache', () => {\n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]', 'A [v1]', 'A [v2]']);\n+    assertLog(['A [v1]', 'A [v1]', 'A [v2]']);\n     expect(root).toMatchRenderedOutput('A [v1]A [v1]A [v2]');\n \n     // Unmount children: the first text cache instance is created only after the root\n@@ -1211,10 +1158,7 @@ describe('ReactCache', () => {\n     await act(async () => {\n       root.render('Bye!');\n     });\n-    expect(Scheduler).toHaveYielded([\n-      'Cache cleanup: A [v1]',\n-      'Cache cleanup: A [v2]',\n-    ]);\n+    assertLog(['Cache cleanup: A [v1]', 'Cache cleanup: A [v2]']);\n     expect(root).toMatchRenderedOutput('Bye!');\n   });\n \n@@ -1257,21 +1201,21 @@ describe('ReactCache', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['0']);\n+    assertLog(['0']);\n     expect(root).toMatchRenderedOutput('0');\n \n     await act(async () => {\n       startTransition(() => {\n         showMore();\n       });\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);\n+    assertLog(['Cache miss! [A]', 'Loading...']);\n     expect(root).toMatchRenderedOutput('0');\n \n     await act(async () => {\n       updateUnrelated(1);\n     });\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       '1',\n \n       // Happens to re-render the fallback. Doesn't need to, but not relevant\n@@ -1283,7 +1227,7 @@ describe('ReactCache', () => {\n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]']);\n+    assertLog(['A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]1');\n \n     // Unmount children: the first text cache instance is created only after initial\n@@ -1293,7 +1237,7 @@ describe('ReactCache', () => {\n     await act(async () => {\n       root.render('Bye!');\n     });\n-    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v1]']);\n+    assertLog(['Cache cleanup: A [v1]']);\n     expect(root).toMatchRenderedOutput('Bye!');\n   });\n \n@@ -1310,7 +1254,7 @@ describe('ReactCache', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]']);\n+    assertLog(['A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     seedNextTextCache('B');\n@@ -1323,7 +1267,7 @@ describe('ReactCache', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['B [v2]']);\n+    assertLog(['B [v2]']);\n     expect(root).toMatchRenderedOutput('B [v2]');\n \n     // Unmount children: the fresh cache instance for B cleans up since the cache boundary\n@@ -1332,7 +1276,7 @@ describe('ReactCache', () => {\n     await act(async () => {\n       root.render('Bye!');\n     });\n-    expect(Scheduler).toHaveYielded(['Cache cleanup: B [v2]']);\n+    assertLog(['Cache cleanup: B [v2]']);\n     expect(root).toMatchRenderedOutput('Bye!');\n   });\n \n@@ -1348,13 +1292,13 @@ describe('ReactCache', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]']);\n+    assertLog(['Cache miss! [A]']);\n     expect(root).toMatchRenderedOutput('Loading...');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]']);\n+    assertLog(['A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     // After a mount, subsequent transitions use a fresh cache\n@@ -1369,7 +1313,7 @@ describe('ReactCache', () => {\n         );\n       });\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [B]']);\n+    assertLog(['Cache miss! [B]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     // Update to a different text and with a different key for the cache\n@@ -1386,24 +1330,21 @@ describe('ReactCache', () => {\n         );\n       });\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [C]']);\n+    assertLog(['Cache miss! [C]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     await act(async () => {\n       resolveMostRecentTextCache('C');\n     });\n-    expect(Scheduler).toHaveYielded(['C [v2]']);\n+    assertLog(['C [v2]']);\n     expect(root).toMatchRenderedOutput('C [v2]');\n \n     // Unmount children: the fresh cache used for the updates is freed, while the\n     // original cache (with A) is still retained at the root.\n     await act(async () => {\n       root.render('Bye!');\n     });\n-    expect(Scheduler).toHaveYielded([\n-      'Cache cleanup: B [v2]',\n-      'Cache cleanup: C [v2]',\n-    ]);\n+    assertLog(['Cache cleanup: B [v2]', 'Cache cleanup: C [v2]']);\n     expect(root).toMatchRenderedOutput('Bye!');\n   });\n \n@@ -1419,13 +1360,13 @@ describe('ReactCache', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]']);\n+    assertLog(['Cache miss! [A]']);\n     expect(root).toMatchRenderedOutput('Loading...');\n \n     await act(async () => {\n       resolveMostRecentTextCache('A');\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]']);\n+    assertLog(['A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     // After a mount, subsequent updates use a fresh cache\n@@ -1438,7 +1379,7 @@ describe('ReactCache', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [B]']);\n+    assertLog(['Cache miss! [B]']);\n     expect(root).toMatchRenderedOutput('Loading...');\n \n     // A second update uses the same fresh cache: even though this is a new\n@@ -1452,24 +1393,21 @@ describe('ReactCache', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [C]']);\n+    assertLog(['Cache miss! [C]']);\n     expect(root).toMatchRenderedOutput('Loading...');\n \n     await act(async () => {\n       resolveMostRecentTextCache('C');\n     });\n-    expect(Scheduler).toHaveYielded(['C [v2]']);\n+    assertLog(['C [v2]']);\n     expect(root).toMatchRenderedOutput('C [v2]');\n \n     // Unmount children: the fresh cache used for the updates is freed, while the\n     // original cache (with A) is still retained at the root.\n     await act(async () => {\n       root.render('Bye!');\n     });\n-    expect(Scheduler).toHaveYielded([\n-      'Cache cleanup: B [v2]',\n-      'Cache cleanup: C [v2]',\n-    ]);\n+    assertLog(['Cache cleanup: B [v2]', 'Cache cleanup: C [v2]']);\n     expect(root).toMatchRenderedOutput('Bye!');\n   });\n \n@@ -1486,7 +1424,7 @@ describe('ReactCache', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]']);\n+    assertLog(['A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     // Start a transition from A -> B..., which should create a fresh cache\n@@ -1502,7 +1440,7 @@ describe('ReactCache', () => {\n         );\n       });\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [B]']);\n+    assertLog(['Cache miss! [B]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     // ...but cancel by transitioning \"back\" to A (which we never really left)\n@@ -1517,14 +1455,14 @@ describe('ReactCache', () => {\n         );\n       });\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]', 'Cache cleanup: B [v2]']);\n+    assertLog(['A [v1]', 'Cache cleanup: B [v2]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     // Unmount children: ...\n     await act(async () => {\n       root.render('Bye!');\n     });\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(root).toMatchRenderedOutput('Bye!');\n   });\n \n@@ -1544,21 +1482,21 @@ describe('ReactCache', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]']);\n+    assertLog(['A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     await act(async () => {\n       startTransition(() => {\n         refresh();\n       });\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]']);\n+    assertLog(['Cache miss! [A]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     await act(async () => {\n       root.render('Bye!');\n     });\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       // TODO: the v1 cache should *not* be cleaned up, it is still retained by the root\n       // The following line is presently yielded but should not be:\n       // 'Cache cleanup: A [v1]',\n@@ -1588,22 +1526,22 @@ describe('ReactCache', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['A [v1]']);\n+    assertLog(['A [v1]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     await act(async () => {\n       startTransition(() => {\n         refresh();\n       });\n     });\n-    expect(Scheduler).toHaveYielded(['Cache miss! [A]']);\n+    assertLog(['Cache miss! [A]']);\n     expect(root).toMatchRenderedOutput('A [v1]');\n \n     // Unmount the boundary before the refresh can complete\n     await act(async () => {\n       root.render('Bye!');\n     });\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       // TODO: the v2 cache *should* be cleaned up, it was created for the abandoned refresh\n       // The following line is presently not yielded but should be:\n       'Cache cleanup: A [v2]',\n@@ -1632,14 +1570,14 @@ describe('ReactCache', () => {\n     await act(async () => {\n       root.render(<App prerenderMore={false} />);\n     });\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(root).toMatchRenderedOutput(<div hidden={true} />);\n \n     seedNextTextCache('More');\n     await act(async () => {\n       root.render(<App prerenderMore={true} />);\n     });\n-    expect(Scheduler).toHaveYielded(['More']);\n+    assertLog(['More']);\n     expect(root).toMatchRenderedOutput(<div hidden={true}>More</div>);\n   });\n ",
  },
  {
    sha: "216da08c96ae2c9020eb82d1edbe47ce89924f27",
    filename:
      "packages/react-reconciler/src/__tests__/ReactClassSetStateCallback-test.js",
    status: "modified",
    additions: 6,
    deletions: 2,
    changes: 8,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactClassSetStateCallback-test.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactClassSetStateCallback-test.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactClassSetStateCallback-test.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -2,6 +2,7 @@ let React;\n let ReactNoop;\n let Scheduler;\n let act;\n+let assertLog;\n \n describe('ReactClassSetStateCallback', () => {\n   beforeEach(() => {\n@@ -11,6 +12,9 @@ describe('ReactClassSetStateCallback', () => {\n     ReactNoop = require('react-noop-renderer');\n     Scheduler = require('scheduler');\n     act = require('jest-react').act;\n+\n+    const InternalTestUtils = require('internal-test-utils');\n+    assertLog = InternalTestUtils.assertLog;\n   });\n \n   function Text({text}) {\n@@ -32,7 +36,7 @@ describe('ReactClassSetStateCallback', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded([0]);\n+    assertLog([0]);\n \n     await act(async () => {\n       if (gate(flags => flags.enableUnifiedSyncLane)) {\n@@ -52,6 +56,6 @@ describe('ReactClassSetStateCallback', () => {\n         );\n       });\n     });\n-    expect(Scheduler).toHaveYielded([2, 'Callback 2', 2, 'Callback 1']);\n+    assertLog([2, 'Callback 2', 2, 'Callback 1']);\n   });\n });",
  },
  {
    sha: "7d7d11c53cab6c11f48d68f8fc44c8048f4b15db",
    filename:
      "packages/react-reconciler/src/__tests__/ReactConcurrentErrorRecovery-test.js",
    status: "modified",
    additions: 22,
    deletions: 57,
    changes: 79,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactConcurrentErrorRecovery-test.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactConcurrentErrorRecovery-test.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactConcurrentErrorRecovery-test.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -5,6 +5,7 @@ let act;\n let Suspense;\n let getCacheForType;\n let startTransition;\n+let assertLog;\n \n let caches;\n let seededCache;\n@@ -20,6 +21,9 @@ describe('ReactConcurrentErrorRecovery', () => {\n     Suspense = React.Suspense;\n     startTransition = React.startTransition;\n \n+    const InternalTestUtils = require('internal-test-utils');\n+    assertLog = InternalTestUtils.assertLog;\n+\n     getCacheForType = React.unstable_getCacheForType;\n \n     caches = [];\n@@ -196,7 +200,7 @@ describe('ReactConcurrentErrorRecovery', () => {\n     await act(async () => {\n       root.render(<App step={1} />);\n     });\n-    expect(Scheduler).toHaveYielded(['A1', 'B1']);\n+    assertLog(['A1', 'B1']);\n     expect(root).toMatchRenderedOutput('A1B1');\n \n     // Start a refresh transition\n@@ -205,12 +209,7 @@ describe('ReactConcurrentErrorRecovery', () => {\n         root.render(<App step={2} />);\n       });\n     });\n-    expect(Scheduler).toHaveYielded([\n-      'Suspend! [A2]',\n-      'Loading...',\n-      'Suspend! [B2]',\n-      'Loading...',\n-    ]);\n+    assertLog(['Suspend! [A2]', 'Loading...', 'Suspend! [B2]', 'Loading...']);\n     // Because this is a refresh, we don't switch to a fallback\n     expect(root).toMatchRenderedOutput('A1B1');\n \n@@ -222,7 +221,7 @@ describe('ReactConcurrentErrorRecovery', () => {\n     // Because we're still suspended on A, we can't show an error boundary. We\n     // should wait for A to resolve.\n     if (gate(flags => flags.replayFailedUnitOfWorkWithInvokeGuardedCallback)) {\n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         'Suspend! [A2]',\n         'Loading...',\n \n@@ -233,12 +232,7 @@ describe('ReactConcurrentErrorRecovery', () => {\n         'Oops!',\n       ]);\n     } else {\n-      expect(Scheduler).toHaveYielded([\n-        'Suspend! [A2]',\n-        'Loading...',\n-        'Error! [B2]',\n-        'Oops!',\n-      ]);\n+      assertLog(['Suspend! [A2]', 'Loading...', 'Error! [B2]', 'Oops!']);\n     }\n     // Remain on previous screen.\n     expect(root).toMatchRenderedOutput('A1B1');\n@@ -248,7 +242,7 @@ describe('ReactConcurrentErrorRecovery', () => {\n       resolveText('A2');\n     });\n     if (gate(flags => flags.replayFailedUnitOfWorkWithInvokeGuardedCallback)) {\n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         'A2',\n         'Error! [B2]',\n         // This extra log happens when we replay the error\n@@ -264,15 +258,7 @@ describe('ReactConcurrentErrorRecovery', () => {\n         'Oops!',\n       ]);\n     } else {\n-      expect(Scheduler).toHaveYielded([\n-        'A2',\n-        'Error! [B2]',\n-        'Oops!',\n-\n-        'A2',\n-        'Error! [B2]',\n-        'Oops!',\n-      ]);\n+      assertLog(['A2', 'Error! [B2]', 'Oops!', 'A2', 'Error! [B2]', 'Oops!']);\n     }\n     // Now we can show the error boundary that's wrapped around B.\n     expect(root).toMatchRenderedOutput('A2Oops!');\n@@ -317,7 +303,7 @@ describe('ReactConcurrentErrorRecovery', () => {\n     await act(async () => {\n       root.render(<App step={1} />);\n     });\n-    expect(Scheduler).toHaveYielded(['A1', 'B1']);\n+    assertLog(['A1', 'B1']);\n     expect(root).toMatchRenderedOutput('A1B1');\n \n     // Start a refresh transition\n@@ -326,12 +312,7 @@ describe('ReactConcurrentErrorRecovery', () => {\n         root.render(<App step={2} />);\n       });\n     });\n-    expect(Scheduler).toHaveYielded([\n-      'Suspend! [A2]',\n-      'Loading...',\n-      'Suspend! [B2]',\n-      'Loading...',\n-    ]);\n+    assertLog(['Suspend! [A2]', 'Loading...', 'Suspend! [B2]', 'Loading...']);\n     // Because this is a refresh, we don't switch to a fallback\n     expect(root).toMatchRenderedOutput('A1B1');\n \n@@ -343,7 +324,7 @@ describe('ReactConcurrentErrorRecovery', () => {\n     // Because we're still suspended on B, we can't show an error boundary. We\n     // should wait for B to resolve.\n     if (gate(flags => flags.replayFailedUnitOfWorkWithInvokeGuardedCallback)) {\n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         'Error! [A2]',\n         // This extra log happens when we replay the error\n         // in invokeGuardedCallback\n@@ -354,12 +335,7 @@ describe('ReactConcurrentErrorRecovery', () => {\n         'Loading...',\n       ]);\n     } else {\n-      expect(Scheduler).toHaveYielded([\n-        'Error! [A2]',\n-        'Oops!',\n-        'Suspend! [B2]',\n-        'Loading...',\n-      ]);\n+      assertLog(['Error! [A2]', 'Oops!', 'Suspend! [B2]', 'Loading...']);\n     }\n     // Remain on previous screen.\n     expect(root).toMatchRenderedOutput('A1B1');\n@@ -369,7 +345,7 @@ describe('ReactConcurrentErrorRecovery', () => {\n       resolveText('B2');\n     });\n     if (gate(flags => flags.replayFailedUnitOfWorkWithInvokeGuardedCallback)) {\n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         'Error! [A2]',\n         // This extra log happens when we replay the error\n         // in invokeGuardedCallback\n@@ -385,15 +361,7 @@ describe('ReactConcurrentErrorRecovery', () => {\n         'B2',\n       ]);\n     } else {\n-      expect(Scheduler).toHaveYielded([\n-        'Error! [A2]',\n-        'Oops!',\n-        'B2',\n-\n-        'Error! [A2]',\n-        'Oops!',\n-        'B2',\n-      ]);\n+      assertLog(['Error! [A2]', 'Oops!', 'B2', 'Error! [A2]', 'Oops!', 'B2']);\n     }\n     // Now we can show the error boundary that's wrapped around B.\n     expect(root).toMatchRenderedOutput('Oops!B2');\n@@ -422,7 +390,7 @@ describe('ReactConcurrentErrorRecovery', () => {\n         root.render(<AsyncText text=\"Async\" />);\n       });\n     });\n-    expect(Scheduler).toHaveYielded(['Suspend! [Async]']);\n+    assertLog(['Suspend! [Async]']);\n     expect(root).toMatchRenderedOutput(null);\n \n     // This also works if the suspended component is wrapped with an error\n@@ -438,14 +406,14 @@ describe('ReactConcurrentErrorRecovery', () => {\n         );\n       });\n     });\n-    expect(Scheduler).toHaveYielded(['Suspend! [Async]']);\n+    assertLog(['Suspend! [Async]']);\n     expect(root).toMatchRenderedOutput(null);\n \n     // Continues rendering once data resolves\n     await act(async () => {\n       resolveText('Async');\n     });\n-    expect(Scheduler).toHaveYielded(['Async']);\n+    assertLog(['Async']);\n     expect(root).toMatchRenderedOutput('Async');\n   });\n \n@@ -489,7 +457,7 @@ describe('ReactConcurrentErrorRecovery', () => {\n           );\n         });\n       });\n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         'Suspend! [Async]',\n         // TODO: Ideally we would skip this second render pass to render the\n         // error UI, since it's not going to commit anyway. The same goes for\n@@ -510,17 +478,14 @@ describe('ReactConcurrentErrorRecovery', () => {\n           );\n         });\n       });\n-      expect(Scheduler).toHaveYielded([\n-        'Suspend! [Async]',\n-        'Caught an error: Oops!',\n-      ]);\n+      assertLog(['Suspend! [Async]', 'Caught an error: Oops!']);\n       expect(root).toMatchRenderedOutput(null);\n \n       await act(async () => {\n         await resolveText('Async');\n       });\n \n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         'Async',\n         'Caught an error: Oops!',\n ",
  },
  {
    sha: "65eccd01dddd634ae3258f8b0d785d180c7c260e",
    filename:
      "packages/react-reconciler/src/__tests__/ReactContextPropagation-test.js",
    status: "modified",
    additions: 36,
    deletions: 37,
    changes: 73,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactContextPropagation-test.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactContextPropagation-test.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactContextPropagation-test.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -9,6 +9,7 @@ let SuspenseList;\n let getCacheForType;\n let caches;\n let seededCache;\n+let assertLog;\n \n describe('ReactLazyContextPropagation', () => {\n   beforeEach(() => {\n@@ -25,6 +26,9 @@ describe('ReactLazyContextPropagation', () => {\n       SuspenseList = React.SuspenseList;\n     }\n \n+    const InternalTestUtils = require('internal-test-utils');\n+    assertLog = InternalTestUtils.assertLog;\n+\n     getCacheForType = React.unstable_getCacheForType;\n \n     caches = [];\n@@ -202,13 +206,13 @@ describe('ReactLazyContextPropagation', () => {\n       await act(async () => {\n         root.render(<App />);\n       });\n-      expect(Scheduler).toHaveYielded([0]);\n+      assertLog([0]);\n       expect(root).toMatchRenderedOutput('0');\n \n       await act(async () => {\n         setValue(1);\n       });\n-      expect(Scheduler).toHaveYielded([1]);\n+      assertLog([1]);\n       expect(root).toMatchRenderedOutput('1');\n     },\n   );\n@@ -244,13 +248,13 @@ describe('ReactLazyContextPropagation', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded([0]);\n+    assertLog([0]);\n     expect(root).toMatchRenderedOutput('0');\n \n     await act(async () => {\n       setValue(1);\n     });\n-    expect(Scheduler).toHaveYielded([1]);\n+    assertLog([1]);\n     expect(root).toMatchRenderedOutput('1');\n   });\n \n@@ -287,13 +291,13 @@ describe('ReactLazyContextPropagation', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded([0]);\n+    assertLog([0]);\n     expect(root).toMatchRenderedOutput('0');\n \n     await act(async () => {\n       setValue(1);\n     });\n-    expect(Scheduler).toHaveYielded([1]);\n+    assertLog([1]);\n     expect(root).toMatchRenderedOutput('1');\n   });\n \n@@ -325,7 +329,7 @@ describe('ReactLazyContextPropagation', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['Consumer', 0]);\n+    assertLog(['Consumer', 0]);\n     expect(root).toMatchRenderedOutput('0');\n \n     await act(async () => {\n@@ -335,12 +339,7 @@ describe('ReactLazyContextPropagation', () => {\n       setOtherValue(1);\n       setOtherValue(0);\n     });\n-    // NOTE: If this didn't yield anything, that indicates that we never visited\n-    // the consumer during the render phase, which probably means the eager\n-    // bailout mechanism kicked in. Because we're testing the _lazy_ bailout\n-    // mechanism, update this test to foil the _eager_ bailout, somehow. Perhaps\n-    // by switching to useReducer.\n-    expect(Scheduler).toHaveYielded(['Consumer']);\n+    assertLog(['Consumer']);\n     expect(root).toMatchRenderedOutput('0');\n   });\n \n@@ -387,21 +386,21 @@ describe('ReactLazyContextPropagation', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['A', 'A']);\n+    assertLog(['A', 'A']);\n     expect(root).toMatchRenderedOutput('AA');\n \n     await act(async () => {\n       // Intentionally not wrapping in startTransition, so that the fallback\n       // the fallback displays despite this being a refresh.\n       setContext('B');\n     });\n-    expect(Scheduler).toHaveYielded(['Suspend! [B]', 'Loading...', 'B']);\n+    assertLog(['Suspend! [B]', 'Loading...', 'B']);\n     expect(root).toMatchRenderedOutput('Loading...B');\n \n     await act(async () => {\n       await resolveText('B');\n     });\n-    expect(Scheduler).toHaveYielded(['B']);\n+    assertLog(['B']);\n     expect(root).toMatchRenderedOutput('BB');\n   });\n \n@@ -467,21 +466,21 @@ describe('ReactLazyContextPropagation', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['A', 'A', 'A']);\n+    assertLog(['A', 'A', 'A']);\n     expect(root).toMatchRenderedOutput('AAA');\n \n     await act(async () => {\n       // Intentionally not wrapping in startTransition, so that the fallback\n       // the fallback displays despite this being a refresh.\n       setContext('B');\n     });\n-    expect(Scheduler).toHaveYielded(['Suspend! [B]', 'Loading...', 'B']);\n+    assertLog(['Suspend! [B]', 'Loading...', 'B']);\n     expect(root).toMatchRenderedOutput('Loading...B');\n \n     await act(async () => {\n       await resolveText('B');\n     });\n-    expect(Scheduler).toHaveYielded(['B', 'B']);\n+    assertLog(['B', 'B']);\n     expect(root).toMatchRenderedOutput('BBB');\n   });\n \n@@ -528,21 +527,21 @@ describe('ReactLazyContextPropagation', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['A', 'A']);\n+    assertLog(['A', 'A']);\n     expect(root).toMatchRenderedOutput('AA');\n \n     await act(async () => {\n       // Intentionally not wrapping in startTransition, so that the fallback\n       // the fallback displays despite this being a refresh.\n       setContext('B');\n     });\n-    expect(Scheduler).toHaveYielded(['Suspend! [B]', 'Loading...', 'B']);\n+    assertLog(['Suspend! [B]', 'Loading...', 'B']);\n     expect(root).toMatchRenderedOutput('Loading...B');\n \n     await act(async () => {\n       await resolveText('B');\n     });\n-    expect(Scheduler).toHaveYielded(['B']);\n+    assertLog(['B']);\n     expect(root).toMatchRenderedOutput('BB');\n   });\n \n@@ -582,13 +581,13 @@ describe('ReactLazyContextPropagation', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['A', 'A']);\n+    assertLog(['A', 'A']);\n     expect(root).toMatchRenderedOutput('AA');\n \n     await act(async () => {\n       setContext('B');\n     });\n-    expect(Scheduler).toHaveYielded(['B', 'B']);\n+    assertLog(['B', 'B']);\n     expect(root).toMatchRenderedOutput('BB');\n   });\n \n@@ -643,13 +642,13 @@ describe('ReactLazyContextPropagation', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['A', 'A', 'A']);\n+    assertLog(['A', 'A', 'A']);\n     expect(root).toMatchRenderedOutput('AAA');\n \n     await act(async () => {\n       setContext('B');\n     });\n-    expect(Scheduler).toHaveYielded(['B', 'B', 'B']);\n+    assertLog(['B', 'B', 'B']);\n     expect(root).toMatchRenderedOutput('BBB');\n   });\n \n@@ -685,13 +684,13 @@ describe('ReactLazyContextPropagation', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['A', 'A']);\n+    assertLog(['A', 'A']);\n     expect(root).toMatchRenderedOutput('AA');\n \n     await act(async () => {\n       setContext('B');\n     });\n-    expect(Scheduler).toHaveYielded(['B', 'B']);\n+    assertLog(['B', 'B']);\n     expect(root).toMatchRenderedOutput('BB');\n   });\n \n@@ -739,13 +738,13 @@ describe('ReactLazyContextPropagation', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['A', 'A']);\n+    assertLog(['A', 'A']);\n     expect(root).toMatchRenderedOutput('AA');\n \n     await act(async () => {\n       setContext('B');\n     });\n-    expect(Scheduler).toHaveYielded(['B', 'B']);\n+    assertLog(['B', 'B']);\n     expect(root).toMatchRenderedOutput('BB');\n   });\n \n@@ -802,19 +801,19 @@ describe('ReactLazyContextPropagation', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['A', 'A']);\n+    assertLog(['A', 'A']);\n     expect(root).toMatchRenderedOutput('AA');\n \n     await act(async () => {\n       setContext('B');\n     });\n-    expect(Scheduler).toHaveYielded(['Suspend! [B]', 'Loading...']);\n+    assertLog(['Suspend! [B]', 'Loading...']);\n     expect(root).toMatchRenderedOutput('Loading...');\n \n     await act(async () => {\n       await resolveText('B');\n     });\n-    expect(Scheduler).toHaveYielded(['B', 'B']);\n+    assertLog(['B', 'B']);\n     expect(root).toMatchRenderedOutput('BB');\n   });\n \n@@ -863,13 +862,13 @@ describe('ReactLazyContextPropagation', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['A', 'A']);\n+    assertLog(['A', 'A']);\n     expect(root).toMatchRenderedOutput('AA');\n \n     await act(async () => {\n       setContext('B');\n     });\n-    expect(Scheduler).toHaveYielded(['B', 'B']);\n+    assertLog(['B', 'B']);\n     expect(root).toMatchRenderedOutput('BB');\n   });\n \n@@ -912,13 +911,13 @@ describe('ReactLazyContextPropagation', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['A', 'A']);\n+    assertLog(['A', 'A']);\n     expect(root).toMatchRenderedOutput('AA');\n \n     await act(async () => {\n       setContext('B');\n     });\n-    expect(Scheduler).toHaveYielded(['B', 'B']);\n+    assertLog(['B', 'B']);\n     expect(root).toMatchRenderedOutput('BB');\n   });\n });",
  },
  {
    sha: "dd9053afc1c3e1a271e7c1291610a7bd16daec6f",
    filename:
      "packages/react-reconciler/src/__tests__/ReactDeferredValue-test.js",
    status: "modified",
    additions: 22,
    deletions: 25,
    changes: 47,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactDeferredValue-test.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactDeferredValue-test.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactDeferredValue-test.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -15,6 +15,8 @@ let startTransition;\n let useDeferredValue;\n let useMemo;\n let useState;\n+let assertLog;\n+let waitForPaint;\n \n describe('ReactDeferredValue', () => {\n   beforeEach(() => {\n@@ -28,6 +30,10 @@ describe('ReactDeferredValue', () => {\n     useDeferredValue = React.useDeferredValue;\n     useMemo = React.useMemo;\n     useState = React.useState;\n+\n+    const InternalTestUtils = require('internal-test-utils');\n+    assertLog = InternalTestUtils.assertLog;\n+    waitForPaint = InternalTestUtils.waitForPaint;\n   });\n \n   function Text({text}) {\n@@ -65,15 +71,14 @@ describe('ReactDeferredValue', () => {\n     await act(async () => {\n       root.render(<App value={1} />);\n     });\n-    expect(Scheduler).toHaveYielded(['Original: 1', 'Deferred: 1']);\n+    assertLog(['Original: 1', 'Deferred: 1']);\n \n     // If it's an urgent update, the value is deferred\n     await act(async () => {\n       root.render(<App value={2} />);\n \n-      expect(Scheduler).toFlushUntilNextPaint(['Original: 2']);\n-      // The deferred value updates in a separate render\n-      expect(Scheduler).toFlushUntilNextPaint(['Deferred: 2']);\n+      await waitForPaint(['Original: 2']);\n+      await waitForPaint(['Deferred: 2']);\n     });\n     expect(root).toMatchRenderedOutput(\n       <div>\n@@ -87,8 +92,7 @@ describe('ReactDeferredValue', () => {\n       startTransition(() => {\n         root.render(<App value={3} />);\n       });\n-      // The deferred value updates in the same render as the original\n-      expect(Scheduler).toFlushUntilNextPaint(['Original: 3', 'Deferred: 3']);\n+      await waitForPaint(['Original: 3', 'Deferred: 3']);\n     });\n     expect(root).toMatchRenderedOutput(\n       <div>\n@@ -126,15 +130,14 @@ describe('ReactDeferredValue', () => {\n     await act(async () => {\n       root.render(<App value={1} />);\n     });\n-    expect(Scheduler).toHaveYielded(['Original: 1', 'Deferred: 1']);\n+    assertLog(['Original: 1', 'Deferred: 1']);\n \n     // If it's an urgent update, the value is deferred\n     await act(async () => {\n       root.render(<App value={2} />);\n \n-      expect(Scheduler).toFlushUntilNextPaint(['Original: 2']);\n-      // The deferred value updates in a separate render\n-      expect(Scheduler).toFlushUntilNextPaint(['Deferred: 2']);\n+      await waitForPaint(['Original: 2']);\n+      await waitForPaint(['Deferred: 2']);\n     });\n     expect(root).toMatchRenderedOutput(\n       <div>\n@@ -148,8 +151,7 @@ describe('ReactDeferredValue', () => {\n       startTransition(() => {\n         root.render(<App value={3} />);\n       });\n-      // The deferred value updates in the same render as the original\n-      expect(Scheduler).toFlushUntilNextPaint(['Original: 3', 'Deferred: 3']);\n+      await waitForPaint(['Original: 3', 'Deferred: 3']);\n     });\n     expect(root).toMatchRenderedOutput(\n       <div>\n@@ -192,15 +194,14 @@ describe('ReactDeferredValue', () => {\n     await act(async () => {\n       root.render(<App value={1} />);\n     });\n-    expect(Scheduler).toHaveYielded(['Original: 1', 'Deferred: 1']);\n+    assertLog(['Original: 1', 'Deferred: 1']);\n \n     // If it's an urgent update, the value is deferred\n     await act(async () => {\n       root.render(<App value={2} />);\n \n-      expect(Scheduler).toFlushUntilNextPaint(['Original: 2']);\n-      // The deferred value updates in a separate render\n-      expect(Scheduler).toFlushUntilNextPaint(['Deferred: 2']);\n+      await waitForPaint(['Original: 2']);\n+      await waitForPaint(['Deferred: 2']);\n     });\n     expect(root).toMatchRenderedOutput(\n       <div>\n@@ -214,8 +215,7 @@ describe('ReactDeferredValue', () => {\n       startTransition(() => {\n         root.render(<App value={3} />);\n       });\n-      // The deferred value updates in the same render as the original\n-      expect(Scheduler).toFlushUntilNextPaint(['Original: 3', 'Deferred: 3']);\n+      await waitForPaint(['Original: 3', 'Deferred: 3']);\n     });\n     expect(root).toMatchRenderedOutput(\n       <div>\n@@ -257,7 +257,7 @@ describe('ReactDeferredValue', () => {\n     // Initial render\n     await act(async () => {\n       root.render(<App value={1} />);\n-      expect(Scheduler).toFlushUntilNextPaint(['Original: 1', 'Deferred: 1']);\n+      await waitForPaint(['Original: 1', 'Deferred: 1']);\n       expect(root).toMatchRenderedOutput(\n         <div>\n           <div>Original: 1</div>\n@@ -270,7 +270,7 @@ describe('ReactDeferredValue', () => {\n       startTransition(() => {\n         root.render(<App value={2} />);\n       });\n-      expect(Scheduler).toFlushUntilNextPaint(['Original: 2', 'Deferred: 2']);\n+      await waitForPaint(['Original: 2', 'Deferred: 2']);\n       expect(root).toMatchRenderedOutput(\n         <div>\n           <div>Original: 2</div>\n@@ -281,17 +281,14 @@ describe('ReactDeferredValue', () => {\n \n     await act(async () => {\n       root.render(<App value={3} />);\n-      // In the regression, the memoized value was not updated during non-urgent\n-      // updates, so this would flip the deferred value back to the initial\n-      // value (1) instead of reusing the current one (2).\n-      expect(Scheduler).toFlushUntilNextPaint(['Original: 3']);\n+      await waitForPaint(['Original: 3']);\n       expect(root).toMatchRenderedOutput(\n         <div>\n           <div>Original: 3</div>\n           <div>Deferred: 2</div>\n         </div>,\n       );\n-      expect(Scheduler).toFlushUntilNextPaint(['Deferred: 3']);\n+      await waitForPaint(['Deferred: 3']);\n       expect(root).toMatchRenderedOutput(\n         <div>\n           <div>Original: 3</div>",
  },
  {
    sha: "3af4d3738c441be49376c03187fd1a08b21bd561",
    filename:
      "packages/react-reconciler/src/__tests__/ReactDisableSchedulerTimeoutBasedOnReactExpirationTime-test.internal.js",
    status: "modified",
    additions: 7,
    deletions: 7,
    changes: 14,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactDisableSchedulerTimeoutBasedOnReactExpirationTime-test.internal.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactDisableSchedulerTimeoutBasedOnReactExpirationTime-test.internal.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactDisableSchedulerTimeoutBasedOnReactExpirationTime-test.internal.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -5,6 +5,7 @@ let Scheduler;\n let Suspense;\n let scheduleCallback;\n let NormalPriority;\n+let waitForAll;\n \n describe('ReactSuspenseList', () => {\n   beforeEach(() => {\n@@ -20,6 +21,9 @@ describe('ReactSuspenseList', () => {\n \n     scheduleCallback = Scheduler.unstable_scheduleCallback;\n     NormalPriority = Scheduler.unstable_NormalPriority;\n+\n+    const InternalTestUtils = require('internal-test-utils');\n+    waitForAll = InternalTestUtils.waitForAll;\n   });\n \n   function Text(props) {\n@@ -61,16 +65,12 @@ describe('ReactSuspenseList', () => {\n     const root = ReactNoop.createRoot(null);\n \n     root.render(<App show={false} />);\n-    expect(Scheduler).toFlushAndYield([]);\n+    await waitForAll([]);\n \n     React.startTransition(() => {\n       root.render(<App show={true} />);\n     });\n-    expect(Scheduler).toFlushAndYield([\n-      'Suspend! [A]',\n-      'Suspend! [B]',\n-      'Loading...',\n-    ]);\n+    await waitForAll(['Suspend! [A]', 'Suspend! [B]', 'Loading...']);\n     expect(root).toMatchRenderedOutput(null);\n \n     Scheduler.unstable_advanceTime(2000);\n@@ -92,7 +92,7 @@ describe('ReactSuspenseList', () => {\n     // task should not jump the queue ahead of B.\n     await expect(Scheduler).toFlushAndYieldThrough(['Resolve B']);\n \n-    expect(Scheduler).toFlushAndYield(['A', 'B']);\n+    await waitForAll(['A', 'B']);\n     expect(root).toMatchRenderedOutput('AB');\n   });\n });",
  },
  {
    sha: "90034cf06e5efe113a566aca94d534a2bba0a45a",
    filename:
      "packages/react-reconciler/src/__tests__/ReactEffectOrdering-test.js",
    status: "modified",
    additions: 7,
    deletions: 3,
    changes: 10,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactEffectOrdering-test.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactEffectOrdering-test.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactEffectOrdering-test.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -18,8 +18,9 @@ let Scheduler;\n let act;\n let useEffect;\n let useLayoutEffect;\n+let assertLog;\n \n-describe('ReactHooksWithNoopRenderer', () => {\n+describe('ReactEffectOrdering', () => {\n   beforeEach(() => {\n     jest.resetModules();\n     jest.useFakeTimers();\n@@ -30,6 +31,9 @@ describe('ReactHooksWithNoopRenderer', () => {\n     act = require('jest-react').act;\n     useEffect = React.useEffect;\n     useLayoutEffect = React.useLayoutEffect;\n+\n+    const InternalTestUtils = require('internal-test-utils');\n+    assertLog = InternalTestUtils.assertLog;\n   });\n \n   test('layout unmounts on deletion are fired in parent -> child order', async () => {\n@@ -56,7 +60,7 @@ describe('ReactHooksWithNoopRenderer', () => {\n     await act(async () => {\n       root.render(null);\n     });\n-    expect(Scheduler).toHaveYielded(['Unmount parent', 'Unmount child']);\n+    assertLog(['Unmount parent', 'Unmount child']);\n   });\n \n   test('passive unmounts on deletion are fired in parent -> child order', async () => {\n@@ -83,6 +87,6 @@ describe('ReactHooksWithNoopRenderer', () => {\n     await act(async () => {\n       root.render(null);\n     });\n-    expect(Scheduler).toHaveYielded(['Unmount parent', 'Unmount child']);\n+    assertLog(['Unmount parent', 'Unmount child']);\n   });\n });",
  },
  {
    sha: "2556a16ac3b213b76473b779643b54be3eaba5a8",
    filename: "packages/react-reconciler/src/__tests__/ReactExpiration-test.js",
    status: "modified",
    additions: 67,
    deletions: 86,
    changes: 153,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactExpiration-test.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactExpiration-test.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactExpiration-test.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -18,6 +18,9 @@ let resolveText;\n let startTransition;\n let useState;\n let useEffect;\n+let assertLog;\n+let waitFor;\n+let waitForAll;\n \n describe('ReactExpiration', () => {\n   beforeEach(() => {\n@@ -31,6 +34,11 @@ describe('ReactExpiration', () => {\n     useState = React.useState;\n     useEffect = React.useEffect;\n \n+    const InternalTestUtils = require('internal-test-utils');\n+    assertLog = InternalTestUtils.assertLog;\n+    waitFor = InternalTestUtils.waitFor;\n+    waitForAll = InternalTestUtils.waitForAll;\n+\n     const textCache = new Map();\n \n     readText = text => {\n@@ -136,7 +144,7 @@ describe('ReactExpiration', () => {\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"done\" />);\n   });\n \n-  it('two updates of like priority in the same event always flush within the same batch', () => {\n+  it('two updates of like priority in the same event always flush within the same batch', async () => {\n     class TextClass extends React.Component {\n       componentDidMount() {\n         Scheduler.unstable_yieldValue(`${this.props.text} [commit]`);\n@@ -163,37 +171,32 @@ describe('ReactExpiration', () => {\n     });\n     // Advance the timer.\n     Scheduler.unstable_advanceTime(2000);\n-    // Partially flush the first update, then interrupt it.\n-    expect(Scheduler).toFlushAndYieldThrough(['A [render]']);\n+    await waitFor(['A [render]']);\n     interrupt();\n \n-    // Don't advance time by enough to expire the first update.\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n     // Schedule another update.\n     ReactNoop.render(<TextClass text=\"B\" />);\n-    // Both updates are batched\n-    expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);\n+    await waitForAll(['B [render]', 'B [commit]']);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"B\" />);\n \n     // Now do the same thing again, except this time don't flush any work in\n     // between the two updates.\n     ReactNoop.render(<TextClass text=\"A\" />);\n     Scheduler.unstable_advanceTime(2000);\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"B\" />);\n     // Schedule another update.\n     ReactNoop.render(<TextClass text=\"B\" />);\n-    // The updates should flush in the same batch, since as far as the scheduler\n-    // knows, they may have occurred inside the same event.\n-    expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);\n+    await waitForAll(['B [render]', 'B [commit]']);\n   });\n \n   it(\n     'two updates of like priority in the same event always flush within the ' +\n       \"same batch, even if there's a sync update in between\",\n-    () => {\n+    async () => {\n       class TextClass extends React.Component {\n         componentDidMount() {\n           Scheduler.unstable_yieldValue(`${this.props.text} [commit]`);\n@@ -220,25 +223,22 @@ describe('ReactExpiration', () => {\n       });\n       // Advance the timer.\n       Scheduler.unstable_advanceTime(2000);\n-      // Partially flush the first update, then interrupt it.\n-      expect(Scheduler).toFlushAndYieldThrough(['A [render]']);\n+      await waitFor(['A [render]']);\n       interrupt();\n \n-      // Don't advance time by enough to expire the first update.\n-      expect(Scheduler).toHaveYielded([]);\n+      assertLog([]);\n       expect(ReactNoop).toMatchRenderedOutput(null);\n \n       // Schedule another update.\n       ReactNoop.render(<TextClass text=\"B\" />);\n-      // Both updates are batched\n-      expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);\n+      await waitForAll(['B [render]', 'B [commit]']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"B\" />);\n \n       // Now do the same thing again, except this time don't flush any work in\n       // between the two updates.\n       ReactNoop.render(<TextClass text=\"A\" />);\n       Scheduler.unstable_advanceTime(2000);\n-      expect(Scheduler).toHaveYielded([]);\n+      assertLog([]);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"B\" />);\n \n       // Perform some synchronous work. The scheduler must assume we're inside\n@@ -247,13 +247,11 @@ describe('ReactExpiration', () => {\n \n       // Schedule another update.\n       ReactNoop.render(<TextClass text=\"B\" />);\n-      // The updates should flush in the same batch, since as far as the scheduler\n-      // knows, they may have occurred inside the same event.\n-      expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);\n+      await waitForAll(['B [render]', 'B [commit]']);\n     },\n   );\n \n-  it('cannot update at the same expiration time that is already rendering', () => {\n+  it('cannot update at the same expiration time that is already rendering', async () => {\n     const store = {text: 'initial'};\n     const subscribers = [];\n     class Connected extends React.Component {\n@@ -292,7 +290,7 @@ describe('ReactExpiration', () => {\n     React.startTransition(() => {\n       ReactNoop.render(<App />);\n     });\n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'initial [A] [render]',\n       'initial [B] [render]',\n       'initial [C] [render]',\n@@ -307,24 +305,18 @@ describe('ReactExpiration', () => {\n     React.startTransition(() => {\n       subscribers.forEach(s => s.setState({text: '1'}));\n     });\n-    expect(Scheduler).toFlushAndYieldThrough([\n-      '1 [A] [render]',\n-      '1 [B] [render]',\n-    ]);\n+    await waitFor(['1 [A] [render]', '1 [B] [render]']);\n \n     // Before the update can finish, update again. Even though no time has\n     // advanced, this update should be given a different expiration time than\n     // the currently rendering one. So, C and D should render with 1, not 2.\n     React.startTransition(() => {\n       subscribers.forEach(s => s.setState({text: '2'}));\n     });\n-    expect(Scheduler).toFlushAndYieldThrough([\n-      '1 [C] [render]',\n-      '1 [D] [render]',\n-    ]);\n+    await waitFor(['1 [C] [render]', '1 [D] [render]']);\n   });\n \n-  it('stops yielding if CPU-bound update takes too long to finish', () => {\n+  it('stops yielding if CPU-bound update takes too long to finish', async () => {\n     const root = ReactNoop.createRoot();\n     function App() {\n       return (\n@@ -342,18 +334,18 @@ describe('ReactExpiration', () => {\n       root.render(<App />);\n     });\n \n-    expect(Scheduler).toFlushAndYieldThrough(['A']);\n-    expect(Scheduler).toFlushAndYieldThrough(['B']);\n-    expect(Scheduler).toFlushAndYieldThrough(['C']);\n+    await waitFor(['A']);\n+    await waitFor(['B']);\n+    await waitFor(['C']);\n \n     Scheduler.unstable_advanceTime(10000);\n \n     flushNextRenderIfExpired();\n-    expect(Scheduler).toHaveYielded(['D', 'E']);\n+    assertLog(['D', 'E']);\n     expect(root).toMatchRenderedOutput('ABCDE');\n   });\n \n-  it('root expiration is measured from the time of the first update', () => {\n+  it('root expiration is measured from the time of the first update', async () => {\n     Scheduler.unstable_advanceTime(10000);\n \n     const root = ReactNoop.createRoot();\n@@ -372,14 +364,14 @@ describe('ReactExpiration', () => {\n       root.render(<App />);\n     });\n \n-    expect(Scheduler).toFlushAndYieldThrough(['A']);\n-    expect(Scheduler).toFlushAndYieldThrough(['B']);\n-    expect(Scheduler).toFlushAndYieldThrough(['C']);\n+    await waitFor(['A']);\n+    await waitFor(['B']);\n+    await waitFor(['C']);\n \n     Scheduler.unstable_advanceTime(10000);\n \n     flushNextRenderIfExpired();\n-    expect(Scheduler).toHaveYielded(['D', 'E']);\n+    assertLog(['D', 'E']);\n     expect(root).toMatchRenderedOutput('ABCDE');\n   });\n \n@@ -404,14 +396,14 @@ describe('ReactExpiration', () => {\n \n     // The update should not have expired yet.\n     flushNextRenderIfExpired();\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n \n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n     // Advance the time some more to expire the update.\n     Scheduler.unstable_advanceTime(10000);\n     flushNextRenderIfExpired();\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(ReactNoop).toMatchRenderedOutput('Hi');\n   });\n \n@@ -427,14 +419,14 @@ describe('ReactExpiration', () => {\n       ReactNoop.render('Hi');\n     });\n     flushNextRenderIfExpired();\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n     // Advancing by ~5 seconds should be sufficient to expire the update. (I\n     // used a slightly larger number to allow for possible rounding.)\n     Scheduler.unstable_advanceTime(6000);\n     flushNextRenderIfExpired();\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(ReactNoop).toMatchRenderedOutput('Hi');\n   });\n \n@@ -463,26 +455,24 @@ describe('ReactExpiration', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['Sync pri: 0', 'Normal pri: 0']);\n+    assertLog(['Sync pri: 0', 'Normal pri: 0']);\n     expect(root).toMatchRenderedOutput('Sync pri: 0, Normal pri: 0');\n \n     // First demonstrate what happens when there's no starvation\n     await act(async () => {\n       React.startTransition(() => {\n         updateNormalPri();\n       });\n-      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 0']);\n+      await waitFor(['Sync pri: 0']);\n       updateSyncPri();\n-      expect(Scheduler).toHaveYielded(['Sync pri: 1', 'Normal pri: 0']);\n+      assertLog(['Sync pri: 1', 'Normal pri: 0']);\n \n       // The remaining work hasn't expired, so the render phase is time sliced.\n       // In other words, we can flush just the first child without flushing\n       // the rest.\n       Scheduler.unstable_flushNumberOfYields(1);\n-      // Yield right after first child.\n-      expect(Scheduler).toHaveYielded(['Sync pri: 1']);\n-      // Now do the rest.\n-      expect(Scheduler).toFlushAndYield(['Normal pri: 1']);\n+      assertLog(['Sync pri: 1']);\n+      await waitForAll(['Normal pri: 1']);\n     });\n     expect(root).toMatchRenderedOutput('Sync pri: 1, Normal pri: 1');\n \n@@ -491,7 +481,7 @@ describe('ReactExpiration', () => {\n       React.startTransition(() => {\n         updateNormalPri();\n       });\n-      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 1']);\n+      await waitFor(['Sync pri: 1']);\n \n       // This time, a lot of time has elapsed since the normal pri update\n       // started rendering. (This should advance time by some number that's\n@@ -500,12 +490,12 @@ describe('ReactExpiration', () => {\n       Scheduler.unstable_advanceTime(10000);\n \n       updateSyncPri();\n-      expect(Scheduler).toHaveYielded(['Sync pri: 2', 'Normal pri: 1']);\n+      assertLog(['Sync pri: 2', 'Normal pri: 1']);\n \n       // The remaining work _has_ expired, so the render phase is _not_ time\n       // sliced. Attempting to flush just the first child also flushes the rest.\n       Scheduler.unstable_flushNumberOfYields(1);\n-      expect(Scheduler).toHaveYielded(['Sync pri: 2', 'Normal pri: 2']);\n+      assertLog(['Sync pri: 2', 'Normal pri: 2']);\n     });\n     expect(root).toMatchRenderedOutput('Sync pri: 2, Normal pri: 2');\n   });\n@@ -534,16 +524,16 @@ describe('ReactExpiration', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['Sync pri: 0', 'Idle pri: 0']);\n+    assertLog(['Sync pri: 0', 'Idle pri: 0']);\n     expect(root).toMatchRenderedOutput('Sync pri: 0, Idle pri: 0');\n \n     // First demonstrate what happens when there's no starvation\n     await act(async () => {\n       updateIdlePri();\n-      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 0']);\n+      await waitFor(['Sync pri: 0']);\n       updateSyncPri();\n     });\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       // Interrupt idle update to render sync update\n       'Sync pri: 1',\n       'Idle pri: 0',\n@@ -556,16 +546,15 @@ describe('ReactExpiration', () => {\n     // Do the same thing, but starve the first update\n     await act(async () => {\n       updateIdlePri();\n-      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 1']);\n+      await waitFor(['Sync pri: 1']);\n \n       // Advance a ridiculously large amount of time to demonstrate that the\n       // idle work never expires\n       Scheduler.unstable_advanceTime(100000);\n \n       updateSyncPri();\n     });\n-    // Same thing should happen as last time\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       // Interrupt idle update to render sync update\n       'Sync pri: 2',\n       'Idle pri: 1',\n@@ -597,14 +586,14 @@ describe('ReactExpiration', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['A0', 'B0', 'C']);\n+    assertLog(['A0', 'B0', 'C']);\n     expect(root).toMatchRenderedOutput('A0B0C');\n \n     await act(async () => {\n       startTransition(() => {\n         setA(1);\n       });\n-      expect(Scheduler).toFlushAndYieldThrough(['A1']);\n+      await waitFor(['A1']);\n       startTransition(() => {\n         setB(1);\n       });\n@@ -614,12 +603,12 @@ describe('ReactExpiration', () => {\n       // (entangled), we should be able to finish the in-progress transition\n       // without also including the next one.\n       Scheduler.unstable_flushNumberOfYields(1);\n-      expect(Scheduler).toHaveYielded(['B0', 'C']);\n+      assertLog(['B0', 'C']);\n       expect(root).toMatchRenderedOutput('A1B0C');\n \n       // The next transition also finishes without yielding.\n       Scheduler.unstable_flushNumberOfYields(1);\n-      expect(Scheduler).toHaveYielded(['A1', 'B1', 'C']);\n+      assertLog(['A1', 'B1', 'C']);\n       expect(root).toMatchRenderedOutput('A1B1C');\n     });\n   });\n@@ -642,28 +631,21 @@ describe('ReactExpiration', () => {\n       await resolveText('A0');\n       root.render(<App step={0} />);\n     });\n-    expect(Scheduler).toHaveYielded(['A0', 'B', 'C']);\n+    assertLog(['A0', 'B', 'C']);\n     expect(root).toMatchRenderedOutput('A0BC');\n \n     await act(async () => {\n       React.startTransition(() => {\n         root.render(<App step={1} />);\n       });\n-      expect(Scheduler).toFlushAndYield([\n-        'Suspend! [A1]',\n-        'B',\n-        'C',\n-        'Loading...',\n-      ]);\n+      await waitForAll(['Suspend! [A1]', 'B', 'C', 'Loading...']);\n \n       // Lots of time elapses before the promise resolves\n       Scheduler.unstable_advanceTime(10000);\n       await resolveText('A1');\n-      expect(Scheduler).toHaveYielded(['Promise resolved [A1]']);\n+      assertLog(['Promise resolved [A1]']);\n \n-      // But the update doesn't expire, because it was IO bound. So we can\n-      // partially rendering without finishing.\n-      expect(Scheduler).toFlushAndYieldThrough(['A1']);\n+      await waitFor(['A1']);\n       expect(root).toMatchRenderedOutput('A0BC');\n \n       // Lots more time elapses. We're CPU-bound now, so we should treat this\n@@ -672,7 +654,7 @@ describe('ReactExpiration', () => {\n \n       // The rest of the update finishes without yielding.\n       Scheduler.unstable_flushNumberOfYields(1);\n-      expect(Scheduler).toHaveYielded(['B', 'C']);\n+      assertLog(['B', 'C']);\n     });\n   });\n \n@@ -696,26 +678,26 @@ describe('ReactExpiration', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['A0', 'B0']);\n+    assertLog(['A0', 'B0']);\n \n     await act(async () => {\n       startTransition(() => {\n         setA(1);\n       });\n-      expect(Scheduler).toFlushAndYieldThrough(['A1']);\n+      await waitFor(['A1']);\n \n       // Expire the in-progress update\n       Scheduler.unstable_advanceTime(10000);\n \n       ReactNoop.flushSync(() => {\n         setB(1);\n       });\n-      expect(Scheduler).toHaveYielded(['A0', 'B1']);\n+      assertLog(['A0', 'B1']);\n \n       // Now flush the original update. Because it expired, it should finish\n       // without yielding.\n       Scheduler.unstable_flushNumberOfYields(1);\n-      expect(Scheduler).toHaveYielded(['A1', 'B1']);\n+      assertLog(['A1', 'B1']);\n     });\n   });\n \n@@ -737,7 +719,7 @@ describe('ReactExpiration', () => {\n     await act(async () => {\n       root.render(<App step={0} />);\n     });\n-    expect(Scheduler).toHaveYielded(['A0', 'B0', 'C0', 'Effect: 0']);\n+    assertLog(['A0', 'B0', 'C0', 'Effect: 0']);\n     expect(root).toMatchRenderedOutput('A0B0C0');\n \n     await act(async () => {\n@@ -749,9 +731,8 @@ describe('ReactExpiration', () => {\n \n       // The update finishes without yielding. But it does not flush the effect.\n       Scheduler.unstable_flushNumberOfYields(1);\n-      expect(Scheduler).toHaveYielded(['A1', 'B1', 'C1']);\n+      assertLog(['A1', 'B1', 'C1']);\n     });\n-    // The effect flushes after paint.\n-    expect(Scheduler).toHaveYielded(['Effect: 1']);\n+    assertLog(['Effect: 1']);\n   });\n });",
  },
  {
    sha: "4e3e948c46268366463f4fbacbf39877393574d4",
    filename: "packages/react-reconciler/src/__tests__/ReactFlushSync-test.js",
    status: "modified",
    additions: 37,
    deletions: 31,
    changes: 68,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactFlushSync-test.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactFlushSync-test.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactFlushSync-test.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -5,6 +5,8 @@ let act;\n let useState;\n let useEffect;\n let startTransition;\n+let assertLog;\n+let waitForPaint;\n \n // TODO: Migrate tests to React DOM instead of React Noop\n \n@@ -19,6 +21,10 @@ describe('ReactFlushSync', () => {\n     useState = React.useState;\n     useEffect = React.useEffect;\n     startTransition = React.startTransition;\n+\n+    const InternalTestUtils = require('internal-test-utils');\n+    assertLog = InternalTestUtils.assertLog;\n+    waitForPaint = InternalTestUtils.waitForPaint;\n   });\n \n   function Text({text}) {\n@@ -27,6 +33,8 @@ describe('ReactFlushSync', () => {\n   }\n \n   test('changes priority of updates in useEffect', async () => {\n+    spyOnDev(console, 'error').mockImplementation(() => {});\n+\n     function App() {\n       const [syncState, setSyncState] = useState(0);\n       const [state, setState] = useState(0);\n@@ -44,29 +52,33 @@ describe('ReactFlushSync', () => {\n       React.startTransition(() => {\n         root.render(<App />);\n       });\n-      // This will yield right before the passive effect fires\n-      expect(Scheduler).toFlushUntilNextPaint(['0, 0']);\n+      await waitForPaint(['0, 0']);\n \n       // The passive effect will schedule a sync update and a normal update.\n       // They should commit in two separate batches. First the sync one.\n-      expect(() => {\n-        expect(Scheduler).toFlushUntilNextPaint(\n-          gate(flags => flags.enableUnifiedSyncLane) ? ['1, 1'] : ['1, 0'],\n-        );\n-      }).toErrorDev('flushSync was called from inside a lifecycle method');\n+      await waitForPaint(\n+        gate(flags => flags.enableUnifiedSyncLane) ? ['1, 1'] : ['1, 0'],\n+      );\n \n       // The remaining update is not sync\n       ReactNoop.flushSync();\n-      expect(Scheduler).toHaveYielded([]);\n+      assertLog([]);\n \n       if (gate(flags => flags.enableUnifiedSyncLane)) {\n-        expect(Scheduler).toFlushUntilNextPaint([]);\n+        await waitForPaint([]);\n       } else {\n-        // Now flush it.\n-        expect(Scheduler).toFlushUntilNextPaint(['1, 1']);\n+        await waitForPaint(['1, 1']);\n       }\n     });\n     expect(root).toMatchRenderedOutput('1, 1');\n+\n+    if (__DEV__) {\n+      expect(console.error.mock.calls[0][0]).toContain(\n+        'flushSync was called from inside a lifecycle method. React ' +\n+          'cannot flush when React is already rendering. Consider moving this ' +\n+          'call to a scheduler task or micro task.%s',\n+      );\n+    }\n   });\n \n   test('nested with startTransition', async () => {\n@@ -84,7 +96,7 @@ describe('ReactFlushSync', () => {\n     await act(async () => {\n       root.render(<App />);\n     });\n-    expect(Scheduler).toHaveYielded(['0, 0']);\n+    assertLog(['0, 0']);\n     expect(root).toMatchRenderedOutput('0, 0');\n \n     await act(async () => {\n@@ -100,12 +112,10 @@ describe('ReactFlushSync', () => {\n           });\n         });\n       });\n-      // Only the sync update should have flushed\n-      expect(Scheduler).toHaveYielded(['1, 0']);\n+      assertLog(['1, 0']);\n       expect(root).toMatchRenderedOutput('1, 0');\n     });\n-    // Now the async update has flushed, too.\n-    expect(Scheduler).toHaveYielded(['1, 1']);\n+    assertLog(['1, 1']);\n     expect(root).toMatchRenderedOutput('1, 1');\n   });\n \n@@ -122,7 +132,7 @@ describe('ReactFlushSync', () => {\n       ReactNoop.flushSync(() => {\n         root.render(<App />);\n       });\n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         'Child',\n         // Because the pending effect was the result of a sync update, calling\n         // flushSync should flush it.\n@@ -145,15 +155,14 @@ describe('ReactFlushSync', () => {\n       ReactNoop.flushSync(() => {\n         root.render(<App />);\n       });\n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         'Child',\n         // Because we're in legacy mode, we shouldn't have flushed the passive\n         // effects yet.\n       ]);\n       expect(root).toMatchRenderedOutput('Child');\n     });\n-    // Effect flushes after paint.\n-    expect(Scheduler).toHaveYielded(['Effect']);\n+    assertLog(['Effect']);\n   });\n \n   test('flush pending passive effects before scope is called in legacy mode', async () => {\n@@ -172,7 +181,7 @@ describe('ReactFlushSync', () => {\n       ReactNoop.flushSync(() => {\n         root.render(<App step={1} />);\n       });\n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         1,\n         // Because we're in legacy mode, we shouldn't have flushed the passive\n         // effects yet.\n@@ -184,10 +193,10 @@ describe('ReactFlushSync', () => {\n         // fired, before the scope function is called.\n         root.render(<App step={currentStep + 1} />);\n       });\n-      expect(Scheduler).toHaveYielded(['Effect: 1', 2]);\n+      assertLog(['Effect: 1', 2]);\n       expect(root).toMatchRenderedOutput('2');\n     });\n-    expect(Scheduler).toHaveYielded(['Effect: 2']);\n+    assertLog(['Effect: 2']);\n   });\n \n   test(\"do not flush passive effects synchronously when they aren't the result of a sync render\", async () => {\n@@ -201,15 +210,14 @@ describe('ReactFlushSync', () => {\n     const root = ReactNoop.createRoot();\n     await act(async () => {\n       root.render(<App />);\n-      expect(Scheduler).toFlushUntilNextPaint([\n+      await waitForPaint([\n         'Child',\n         // Because the passive effect was not the result of a sync update, it\n         // should not flush before paint.\n       ]);\n       expect(root).toMatchRenderedOutput('Child');\n     });\n-    // Effect flushes after paint.\n-    expect(Scheduler).toHaveYielded(['Effect']);\n+    assertLog(['Effect']);\n   });\n \n   test('does not flush pending passive effects', async () => {\n@@ -223,15 +231,13 @@ describe('ReactFlushSync', () => {\n     const root = ReactNoop.createRoot();\n     await act(async () => {\n       root.render(<App />);\n-      expect(Scheduler).toFlushUntilNextPaint(['Child']);\n+      await waitForPaint(['Child']);\n       expect(root).toMatchRenderedOutput('Child');\n \n       // Passive effects are pending. Calling flushSync should not affect them.\n       ReactNoop.flushSync();\n-      // Effects still haven't fired.\n-      expect(Scheduler).toHaveYielded([]);\n+      assertLog([]);\n     });\n-    // Now the effects have fired.\n-    expect(Scheduler).toHaveYielded(['Effect']);\n+    assertLog(['Effect']);\n   });\n });",
  },
  {
    sha: "7de3300bf33b716090339906540e63a2aeb9a724",
    filename: "packages/react-reconciler/src/__tests__/ReactFragment-test.js",
    status: "modified",
    additions: 86,
    deletions: 84,
    changes: 170,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactFragment-test.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactFragment-test.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactFragment-test.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -12,6 +12,7 @@\n let React;\n let ReactNoop;\n let Scheduler;\n+let waitForAll;\n \n describe('ReactFragment', () => {\n   beforeEach(function () {\n@@ -20,39 +21,42 @@ describe('ReactFragment', () => {\n     React = require('react');\n     ReactNoop = require('react-noop-renderer');\n     Scheduler = require('scheduler');\n+\n+    const InternalTestUtils = require('internal-test-utils');\n+    waitForAll = InternalTestUtils.waitForAll;\n   });\n \n-  it('should render a single child via noop renderer', () => {\n+  it('should render a single child via noop renderer', async () => {\n     const element = (\n       <>\n         <span>foo</span>\n       </>\n     );\n \n     ReactNoop.render(element);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ReactNoop).toMatchRenderedOutput(<span>foo</span>);\n   });\n \n-  it('should render zero children via noop renderer', () => {\n+  it('should render zero children via noop renderer', async () => {\n     const element = <React.Fragment />;\n \n     ReactNoop.render(element);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ReactNoop).toMatchRenderedOutput(null);\n   });\n \n-  it('should render multiple children via noop renderer', () => {\n+  it('should render multiple children via noop renderer', async () => {\n     const element = (\n       <>\n         hello <span>world</span>\n       </>\n     );\n \n     ReactNoop.render(element);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n@@ -61,13 +65,13 @@ describe('ReactFragment', () => {\n     );\n   });\n \n-  it('should render an iterable via noop renderer', () => {\n+  it('should render an iterable via noop renderer', async () => {\n     const element = (\n       <>{new Set([<span key=\"a\">hi</span>, <span key=\"b\">bye</span>])}</>\n     );\n \n     ReactNoop.render(element);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n@@ -77,7 +81,7 @@ describe('ReactFragment', () => {\n     );\n   });\n \n-  it('should preserve state of children with 1 level nesting', function () {\n+  it('should preserve state of children with 1 level nesting', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -102,10 +106,10 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(\n@@ -116,13 +120,13 @@ describe('ReactFragment', () => {\n     );\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should preserve state between top-level fragments', function () {\n+  it('should preserve state between top-level fragments', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -148,22 +152,22 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should preserve state of children nested at same level', function () {\n+  it('should preserve state of children nested at same level', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -198,10 +202,10 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(\n@@ -212,13 +216,13 @@ describe('ReactFragment', () => {\n     );\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should not preserve state in non-top-level fragment nesting', function () {\n+  it('should not preserve state in non-top-level fragment nesting', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -246,22 +250,22 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should not preserve state of children if nested 2 levels without siblings', function () {\n+  it('should not preserve state of children if nested 2 levels without siblings', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -287,22 +291,22 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should not preserve state of children if nested 2 levels with siblings', function () {\n+  it('should not preserve state of children if nested 2 levels with siblings', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -329,10 +333,10 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(\n@@ -343,13 +347,13 @@ describe('ReactFragment', () => {\n     );\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should preserve state between array nested in fragment and fragment', function () {\n+  it('should preserve state between array nested in fragment and fragment', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -373,22 +377,22 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should preserve state between top level fragment and array', function () {\n+  it('should preserve state between top level fragment and array', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -412,22 +416,22 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should not preserve state between array nested in fragment and double nested fragment', function () {\n+  it('should not preserve state between array nested in fragment and double nested fragment', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -453,22 +457,22 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should not preserve state between array nested in fragment and double nested array', function () {\n+  it('should not preserve state between array nested in fragment and double nested array', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -490,22 +494,22 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should preserve state between double nested fragment and double nested array', function () {\n+  it('should preserve state between double nested fragment and double nested array', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -531,22 +535,22 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should not preserve state of children when the keys are different', function () {\n+  it('should not preserve state of children when the keys are different', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -573,10 +577,10 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(\n@@ -587,13 +591,13 @@ describe('ReactFragment', () => {\n     );\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should not preserve state between unkeyed and keyed fragment', function () {\n+  it('should not preserve state between unkeyed and keyed fragment', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -619,22 +623,22 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should preserve state with reordering in multiple levels', function () {\n+  it('should preserve state with reordering in multiple levels', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -672,10 +676,10 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(\n@@ -689,7 +693,7 @@ describe('ReactFragment', () => {\n     );\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(\n@@ -703,7 +707,7 @@ describe('ReactFragment', () => {\n     );\n   });\n \n-  it('should not preserve state when switching to a keyed fragment to an array', function () {\n+  it('should not preserve state when switching to a keyed fragment to an array', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -735,7 +739,7 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n     expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(\n@@ -751,7 +755,7 @@ describe('ReactFragment', () => {\n     );\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(\n@@ -762,7 +766,7 @@ describe('ReactFragment', () => {\n     );\n   });\n \n-  it('should not preserve state when switching a nested unkeyed fragment to a passthrough component', function () {\n+  it('should not preserve state when switching a nested unkeyed fragment to a passthrough component', async function () {\n     const ops = [];\n \n     function Passthrough({children}) {\n@@ -796,22 +800,22 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should not preserve state when switching a nested keyed fragment to a passthrough component', function () {\n+  it('should not preserve state when switching a nested keyed fragment to a passthrough component', async function () {\n     const ops = [];\n \n     function Passthrough({children}) {\n@@ -845,22 +849,22 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should not preserve state when switching a nested keyed array to a passthrough component', function () {\n+  it('should not preserve state when switching a nested keyed array to a passthrough component', async function () {\n     const ops = [];\n \n     function Passthrough({children}) {\n@@ -890,22 +894,22 @@ describe('ReactFragment', () => {\n     }\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo condition={false} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n \n     ReactNoop.render(<Foo condition={true} />);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual([]);\n     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);\n   });\n \n-  it('should preserve state when it does not change positions', function () {\n+  it('should preserve state when it does not change positions', async function () {\n     const ops = [];\n \n     class Stateful extends React.Component {\n@@ -940,8 +944,7 @@ describe('ReactFragment', () => {\n     );\n \n     ReactNoop.render(<Foo condition={false} />);\n-    // The key warning gets deduped because it's in the same component.\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(\n@@ -952,8 +955,7 @@ describe('ReactFragment', () => {\n     );\n \n     ReactNoop.render(<Foo condition={true} />);\n-    // The key warning gets deduped because it's in the same component.\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n \n     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);\n     expect(ReactNoop).toMatchRenderedOutput(",
  },
  {
    sha: "3a268504136df2ee933e0b471059d6015da05df2",
    filename:
      "packages/react-reconciler/src/__tests__/ReactSuspenseWithNoopRenderer-test.js",
    status: "modified",
    additions: 224,
    deletions: 332,
    changes: 556,
    blob_url:
      "https://github.com/facebook/react/blob/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactSuspenseWithNoopRenderer-test.js",
    raw_url:
      "https://github.com/facebook/react/raw/4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactSuspenseWithNoopRenderer-test.js",
    contents_url:
      "https://api.github.com/repos/facebook/react/contents/packages%2Freact-reconciler%2Fsrc%2F__tests__%2FReactSuspenseWithNoopRenderer-test.js?ref=4b9c9392a6cb04b57cf6a31dcdf4a1cc37ad4ad5",
    patch:
      "@@ -280,13 +280,13 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Render empty shell.\n     ReactNoop.render(<Foo />);\n-    expect(Scheduler).toFlushAndYield(['Foo']);\n+    await waitForAll(['Foo']);\n \n     // The update will suspend.\n     React.startTransition(() => {\n       ReactNoop.render(<Foo renderBar={true} />);\n     });\n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'Foo',\n       'Bar',\n       // A suspends\n@@ -299,8 +299,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Resolve the data\n     await resolveText('A');\n-    // Renders successfully\n-    expect(Scheduler).toFlushAndYield(['Foo', 'Bar', 'A', 'B']);\n+    await waitForAll(['Foo', 'Bar', 'A', 'B']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -322,7 +321,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         </Suspense>\n       </Fragment>,\n     );\n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'Suspend! [A]',\n       'Loading A...',\n       'Suspend! [B]',\n@@ -339,7 +338,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     // normal view. The second Suspense should still show the placeholder.\n     await resolveText('A');\n \n-    expect(Scheduler).toFlushAndYield(['A']);\n+    await waitForAll(['A']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -351,7 +350,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     // normal view.\n     await resolveText('B');\n \n-    expect(Scheduler).toFlushAndYield(['B']);\n+    await waitForAll(['B']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -364,7 +363,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n   it('continues rendering siblings after suspending', async () => {\n     // A shell is needed. The update cause it to suspend.\n     ReactNoop.render(<Suspense fallback={<Text text=\"Loading...\" />} />);\n-    expect(Scheduler).toFlushAndYield([]);\n+    await waitForAll([]);\n     // B suspends. Continue rendering the remaining siblings.\n     React.startTransition(() => {\n       ReactNoop.render(\n@@ -376,21 +375,13 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         </Suspense>,\n       );\n     });\n-    // B suspends. Continue rendering the remaining siblings.\n-    expect(Scheduler).toFlushAndYield([\n-      'A',\n-      'Suspend! [B]',\n-      'C',\n-      'D',\n-      'Loading...',\n-    ]);\n+    await waitForAll(['A', 'Suspend! [B]', 'C', 'D', 'Loading...']);\n     // Did not commit yet.\n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n     // Wait for data to resolve\n     await resolveText('B');\n-    // Renders successfully\n-    expect(Scheduler).toFlushAndYield(['A', 'B', 'C', 'D']);\n+    await waitForAll(['A', 'B', 'C', 'D']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -436,18 +427,18 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     }\n \n     ReactNoop.render(<App />);\n-    expect(Scheduler).toFlushAndYield([]);\n+    await waitForAll([]);\n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n     React.startTransition(() => {\n       ReactNoop.render(<App renderContent={true} />);\n     });\n-    expect(Scheduler).toFlushAndYield(['Suspend! [Result]', 'Loading...']);\n+    await waitForAll(['Suspend! [Result]', 'Loading...']);\n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n     await rejectText('Result', new Error('Failed to load: Result'));\n \n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'Error! [Result]',\n \n       // React retries one more time\n@@ -494,12 +485,12 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     }\n \n     ReactNoop.render(<App />);\n-    expect(Scheduler).toFlushAndYield(['Suspend! [Result]', 'Loading...']);\n+    await waitForAll(['Suspend! [Result]', 'Loading...']);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"Loading...\" />);\n \n     await rejectText('Result', new Error('Failed to load: Result'));\n \n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'Error! [Result]',\n \n       // React retries one more time\n@@ -526,9 +517,9 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Initial mount\n     ReactNoop.render(<App highPri=\"A\" lowPri=\"1\" />);\n-    expect(Scheduler).toFlushAndYield(['A', 'Suspend! [1]', 'Loading...']);\n+    await waitForAll(['A', 'Suspend! [1]', 'Loading...']);\n     await resolveText('1');\n-    expect(Scheduler).toFlushAndYield(['A', '1']);\n+    await waitForAll(['A', '1']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -538,7 +529,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Update the low-pri text\n     ReactNoop.render(<App highPri=\"A\" lowPri=\"2\" />);\n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'A',\n       // Suspends\n       'Suspend! [2]',\n@@ -583,13 +574,13 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     }\n \n     ReactNoop.render(<App showA={false} showB={false} />);\n-    expect(Scheduler).toFlushAndYield([]);\n+    await waitForAll([]);\n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n     React.startTransition(() => {\n       ReactNoop.render(<App showA={true} showB={false} />);\n     });\n-    expect(Scheduler).toFlushAndYield(['Suspend! [A]', 'Loading...']);\n+    await waitForAll(['Suspend! [A]', 'Loading...']);\n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n     // Advance React's virtual time by enough to fall into a new async bucket,\n@@ -598,11 +589,11 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     React.startTransition(() => {\n       ReactNoop.render(<App showA={true} showB={true} />);\n     });\n-    expect(Scheduler).toFlushAndYield(['Suspend! [A]', 'B', 'Loading...']);\n+    await waitForAll(['Suspend! [A]', 'B', 'Loading...']);\n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n     await resolveText('A');\n-    expect(Scheduler).toFlushAndYield(['A', 'B']);\n+    await waitForAll(['A', 'B']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -632,7 +623,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       ReactNoop.render(<App hide={true} />);\n     });\n \n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       // The first update suspends\n       'Suspend! [Async]',\n       // but we have another pending update that we can work on\n@@ -675,35 +666,35 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       root.render(<App step={0} shouldSuspend={false} />);\n     });\n     await advanceTimers(1000);\n-    expect(Scheduler).toHaveYielded(['Sibling', 'Step 0']);\n+    assertLog(['Sibling', 'Step 0']);\n \n     // Schedule an update at several distinct expiration times\n     await act(async () => {\n       React.startTransition(() => {\n         root.render(<App step={1} shouldSuspend={true} />);\n       });\n       Scheduler.unstable_advanceTime(1000);\n-      expect(Scheduler).toFlushAndYieldThrough(['Sibling']);\n+      await waitFor(['Sibling']);\n       interrupt();\n \n       React.startTransition(() => {\n         root.render(<App step={2} shouldSuspend={true} />);\n       });\n       Scheduler.unstable_advanceTime(1000);\n-      expect(Scheduler).toFlushAndYieldThrough(['Sibling']);\n+      await waitFor(['Sibling']);\n       interrupt();\n \n       React.startTransition(() => {\n         root.render(<App step={3} shouldSuspend={true} />);\n       });\n       Scheduler.unstable_advanceTime(1000);\n-      expect(Scheduler).toFlushAndYieldThrough(['Sibling']);\n+      await waitFor(['Sibling']);\n       interrupt();\n \n       root.render(<App step={4} shouldSuspend={false} />);\n     });\n \n-    expect(Scheduler).toHaveYielded(['Sibling', 'Step 4']);\n+    assertLog(['Sibling', 'Step 4']);\n   });\n \n   // @gate enableLegacyCache\n@@ -713,7 +704,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         <Suspense fallback={<Text text=\"Loading...\" />} />\n       </Fragment>,\n     );\n-    expect(Scheduler).toFlushAndYield([]);\n+    await waitForAll([]);\n \n     ReactNoop.render(\n       <Fragment>\n@@ -724,7 +715,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       </Fragment>,\n     );\n \n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       // The async child suspends\n       'Suspend! [Async]',\n       // Render the placeholder\n@@ -739,9 +730,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     // the update.\n     ReactNoop.expire(10000);\n     await advanceTimers(10000);\n-    // No additional rendering work is required, since we already prepared\n-    // the placeholder.\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     // Should have committed the placeholder.\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n@@ -752,7 +741,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Once the promise resolves, we render the suspended view\n     await resolveText('Async');\n-    expect(Scheduler).toFlushAndYield(['Async']);\n+    await waitForAll(['Async']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"Async\" />\n@@ -778,7 +767,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       </Fragment>,\n     );\n \n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'Sync',\n       // The async content suspends\n       'Suspend! [Outer content]',\n@@ -796,7 +785,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Resolve the outer promise.\n     await resolveText('Outer content');\n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'Outer content',\n       'Suspend! [Inner content]',\n       'Loading inner...',\n@@ -824,7 +813,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Finally, flush the inner promise. We should see the complete screen.\n     await resolveText('Inner content');\n-    expect(Scheduler).toFlushAndYield(['Inner content']);\n+    await waitForAll(['Inner content']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"Sync\" />\n@@ -848,7 +837,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         </Fragment>,\n       ),\n     );\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       // The async child suspends\n       'Suspend! [Async]',\n       // We immediately render the fallback UI\n@@ -866,7 +855,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Once the promise resolves, we render the suspended view\n     await resolveText('Async');\n-    expect(Scheduler).toFlushAndYield(['Async']);\n+    await waitForAll(['Async']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"Async\" />\n@@ -889,7 +878,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         </Fragment>,\n       ),\n     );\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       'Suspend! [Async]',\n       'Suspend! [Loading (inner)...]',\n       'Sync',\n@@ -906,7 +895,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         <Suspense fallback={<Text text=\"Loading...\" />} />\n       </Fragment>,\n     );\n-    expect(Scheduler).toFlushAndYield([]);\n+    await waitForAll([]);\n \n     ReactNoop.render(\n       <Fragment>\n@@ -917,7 +906,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       </Fragment>,\n     );\n \n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       // The async child suspends\n       'Suspend! [Async]',\n       'Loading...',\n@@ -932,7 +921,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     // expiration time.\n     ReactNoop.expire(2000);\n     await advanceTimers(2000);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"Loading...\" />\n@@ -942,7 +931,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Once the promise resolves, we render the suspended view\n     await resolveText('Async');\n-    expect(Scheduler).toFlushAndYield(['Async']);\n+    await waitForAll(['Async']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"Async\" />\n@@ -958,7 +947,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         <Suspense fallback={<Text text=\"Loading...\" />} />\n       </Fragment>,\n     );\n-    expect(Scheduler).toFlushAndYield([]);\n+    await waitForAll([]);\n \n     React.startTransition(() => {\n       ReactNoop.render(\n@@ -971,7 +960,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       );\n     });\n \n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       // The async child suspends\n       'Suspend! [Async]',\n       'Loading...',\n@@ -987,13 +976,12 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     await advanceTimers(2000);\n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n-    // Even flushing won't yield a fallback in a transition.\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n     // Once the promise resolves, we render the suspended view\n     await resolveText('Async');\n-    expect(Scheduler).toFlushAndYield(['Async', 'Sync']);\n+    await waitForAll(['Async', 'Sync']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"Async\" />\n@@ -1010,7 +998,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         <Suspense fallback={<Text text=\"Loading...\" />} />\n       </>,\n     );\n-    expect(Scheduler).toFlushAndYield([]);\n+    await waitForAll([]);\n     expect(root).toMatchRenderedOutput(null);\n     React.startTransition(() => {\n       root.render(\n@@ -1022,13 +1010,11 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         </>,\n       );\n     });\n-    expect(Scheduler).toFlushAndYieldThrough(['Suspend! [Async]', 'Sibling']);\n+    await waitFor(['Suspend! [Async]', 'Sibling']);\n \n     await resolveText('Async');\n \n-    // Because we're already showing a fallback, interrupt the current render\n-    // and restart immediately.\n-    expect(Scheduler).toFlushAndYield(['Async', 'Sibling']);\n+    await waitForAll(['Async', 'Sibling']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         <span prop=\"Async\" />\n@@ -1063,17 +1049,13 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         <AsyncText text=\"B\" />\n       </Suspense>,\n     );\n-    expect(Scheduler).toFlushAndYield([\n-      'Suspend! [A]',\n-      'Suspend! [B]',\n-      'Loading...',\n-    ]);\n+    await waitForAll(['Suspend! [A]', 'Suspend! [B]', 'Loading...']);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"Loading...\" />);\n \n     await resolveText('A');\n     await resolveText('B');\n \n-    expect(Scheduler).toFlushAndYield(['A', 'B']);\n+    await waitForAll(['A', 'B']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -1085,7 +1067,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n   // @gate enableLegacyCache\n   it('can resume rendering earlier than a timeout', async () => {\n     ReactNoop.render(<Suspense fallback={<Text text=\"Loading...\" />} />);\n-    expect(Scheduler).toFlushAndYield([]);\n+    await waitForAll([]);\n \n     React.startTransition(() => {\n       ReactNoop.render(\n@@ -1094,13 +1076,12 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toFlushAndYield(['Suspend! [Async]', 'Loading...']);\n+    await waitForAll(['Suspend! [Async]', 'Loading...']);\n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n     // Resolve the promise\n     await resolveText('Async');\n-    // We can now resume rendering\n-    expect(Scheduler).toFlushAndYield(['Async']);\n+    await waitForAll(['Async']);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"Async\" />);\n   });\n \n@@ -1121,37 +1102,34 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     // First mount without suspending. This ensures we already have content\n     // showing so that subsequent updates will suspend.\n     ReactNoop.render(<App text=\"S\" />);\n-    expect(Scheduler).toFlushAndYield(['S']);\n+    await waitForAll(['S']);\n \n     // Schedule an update, and suspend for up to 5 seconds.\n     React.startTransition(() => ReactNoop.render(<App text=\"A\" />));\n-    // The update should suspend.\n-    expect(Scheduler).toFlushAndYield(['Suspend! [A]', 'Loading...']);\n+    await waitForAll(['Suspend! [A]', 'Loading...']);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"S\" />);\n \n     // Advance time until right before it expires.\n     await advanceTimers(4999);\n     ReactNoop.expire(4999);\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"S\" />);\n \n     // Schedule another low priority update.\n     React.startTransition(() => ReactNoop.render(<App text=\"B\" />));\n-    // This update should also suspend.\n-    expect(Scheduler).toFlushAndYield(['Suspend! [B]', 'Loading...']);\n+    await waitForAll(['Suspend! [B]', 'Loading...']);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"S\" />);\n \n     // Schedule a regular update. Its expiration time will fall between\n     // the expiration times of the previous two updates.\n     ReactNoop.render(<App text=\"C\" />);\n-    expect(Scheduler).toFlushAndYield(['C']);\n+    await waitForAll(['C']);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"C\" />);\n \n     // Flush the remaining work.\n     await resolveText('A');\n     await resolveText('B');\n-    // Nothing else to render.\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"C\" />);\n   });\n \n@@ -1188,17 +1166,13 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     jest.advanceTimersByTime(1000);\n     ReactNoop.render(<Foo text=\"goodbye\" />);\n \n-    expect(Scheduler).toFlushAndYield([\n-      'Suspend! [goodbye]',\n-      'Loading...',\n-      'Commit: goodbye',\n-    ]);\n+    await waitForAll(['Suspend! [goodbye]', 'Loading...', 'Commit: goodbye']);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"Loading...\" />);\n \n     await resolveText('goodbye');\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"Loading...\" />);\n \n-    expect(Scheduler).toFlushAndYield(['goodbye']);\n+    await waitForAll(['goodbye']);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"goodbye\" />);\n   });\n \n@@ -1223,18 +1197,14 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     }\n \n     ReactNoop.render(<App />);\n-    expect(Scheduler).toFlushAndYield([\n-      'Suspend! [A]',\n-      'Suspend! [B]',\n-      'Suspend! [C]',\n-    ]);\n+    await waitForAll(['Suspend! [A]', 'Suspend! [B]', 'Suspend! [C]']);\n     expect(ReactNoop).toMatchRenderedOutput('Loading...');\n \n     await resolveText('A');\n     await resolveText('B');\n     await resolveText('C');\n \n-    expect(Scheduler).toFlushAndYield(['A', 'B', 'C']);\n+    await waitForAll(['A', 'B', 'C']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -1257,14 +1227,14 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n       // Times out immediately, ignoring the specified threshold.\n       ReactNoop.renderLegacySyncRoot(<App />);\n-      expect(Scheduler).toHaveYielded(['Suspend! [Result]', 'Loading...']);\n+      assertLog(['Suspend! [Result]', 'Loading...']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"Loading...\" />);\n \n       await act(async () => {\n         resolveText('Result');\n       });\n \n-      expect(Scheduler).toHaveYielded(['Result']);\n+      assertLog(['Result']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"Result\" />);\n     });\n \n@@ -1300,7 +1270,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       // Initial mount.\n       await seedNextTextCache('Step: 1');\n       ReactNoop.renderLegacySyncRoot(<App />);\n-      expect(Scheduler).toHaveYielded(['Step: 1', 'Sibling']);\n+      assertLog(['Step: 1', 'Sibling']);\n       expect(ReactNoop).toMatchRenderedOutput(\n         <>\n           <span prop=\"Step: 1\" />\n@@ -1333,7 +1303,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         resolveText('Step: 2');\n       });\n-      expect(Scheduler).toHaveYielded(['Step: 2']);\n+      assertLog(['Step: 2']);\n       expect(ReactNoop).toMatchRenderedOutput(\n         <>\n           <span prop=\"Step: 2\" />\n@@ -1381,7 +1351,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       ReactNoop.renderLegacySyncRoot(<App />, () =>\n         Scheduler.unstable_yieldValue('Commit root'),\n       );\n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         'A',\n         'Suspend! [B]',\n         'C',\n@@ -1407,7 +1377,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         resolveText('B');\n       });\n \n-      expect(Scheduler).toHaveYielded(['B']);\n+      assertLog(['B']);\n       expect(ReactNoop).toMatchRenderedOutput(\n         <>\n           <span prop=\"A\" />\n@@ -1442,22 +1412,14 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         </Suspense>,\n       );\n \n-      expect(Scheduler).toHaveYielded([\n-        'constructor',\n-        'Suspend! [Hi]',\n-        'Loading...',\n-      ]);\n+      assertLog(['constructor', 'Suspend! [Hi]', 'Loading...']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"Loading...\" />);\n \n       await act(async () => {\n         resolveText('Hi');\n       });\n \n-      expect(Scheduler).toHaveYielded([\n-        'constructor',\n-        'Hi',\n-        'componentDidMount',\n-      ]);\n+      assertLog(['constructor', 'Hi', 'componentDidMount']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"Hi\" />);\n     });\n \n@@ -1489,7 +1451,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n       ReactNoop.renderLegacySyncRoot(<Demo />);\n \n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         'Suspend! [Hi]',\n         'Loading...',\n         // Re-render due to lifecycle update\n@@ -1499,7 +1461,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         resolveText('Hi');\n       });\n-      expect(Scheduler).toHaveYielded(['Hi']);\n+      assertLog(['Hi']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"Hi\" />);\n     });\n \n@@ -1532,7 +1494,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n         ReactNoop.renderLegacySyncRoot(<App middleText=\"B\" />);\n \n-        expect(Scheduler).toHaveYielded([\n+        assertLog([\n           'Suspend! [Hi]',\n           'Loading...',\n           // The child should have already been hidden\n@@ -1545,7 +1507,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         await act(async () => {\n           resolveText('Hi');\n         });\n-        expect(Scheduler).toHaveYielded(['Hi']);\n+        assertLog(['Hi']);\n       });\n     } else {\n       // @gate enableLegacyCache\n@@ -1578,7 +1540,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n         ReactNoop.renderLegacySyncRoot(<App middleText=\"B\" />);\n \n-        expect(Scheduler).toHaveYielded([\n+        assertLog([\n           'Suspend! [Hi]',\n           'Loading...',\n           // The child should have already been hidden\n@@ -1589,7 +1551,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n           resolveText('Hi');\n         });\n \n-        expect(Scheduler).toHaveYielded(['Hi']);\n+        assertLog(['Hi']);\n       });\n     }\n \n@@ -1622,7 +1584,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         </ErrorBoundary>,\n       );\n \n-      expect(Scheduler).toHaveYielded(['Suspend! [Async]']);\n+      assertLog(['Suspend! [Async]']);\n       expect(ReactNoop).toMatchRenderedOutput(\n         'Caught an error: Error in host config.',\n       );\n@@ -1661,7 +1623,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         root.render(<App />);\n       });\n-      expect(Scheduler).toHaveYielded(['Mount']);\n+      assertLog(['Mount']);\n       expect(root).toMatchRenderedOutput('Child');\n \n       // Suspend the child. This puts it into an inconsistent state.\n@@ -1674,7 +1636,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         root.render(null);\n       });\n-      expect(Scheduler).toHaveYielded(['Unmount']);\n+      assertLog(['Unmount']);\n     });\n   });\n \n@@ -1726,7 +1688,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     ReactNoop.renderLegacySyncRoot(<App />, () =>\n       Scheduler.unstable_yieldValue('Commit root'),\n     );\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       'A',\n       'Suspend! [B]',\n       'C',\n@@ -1802,7 +1764,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     ReactNoop.renderLegacySyncRoot(<App text=\"B\" />, () =>\n       Scheduler.unstable_yieldValue('Commit root'),\n     );\n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       'A',\n       'Suspend! [B]',\n       'C',\n@@ -1816,8 +1778,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       'Commit root',\n     ]);\n \n-    // Flush passive effects.\n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'Effect [A]',\n       // B's effect should not fire because it suspended\n       // 'Effect [B]',\n@@ -1837,7 +1798,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       resolveText('B');\n     });\n \n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       'B',\n       'Destroy Layout Effect [Loading...]',\n       'Layout Effect [B]',\n@@ -1850,7 +1811,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       Scheduler.unstable_yieldValue('Commit root'),\n     );\n \n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       'A',\n       'Suspend! [B2]',\n       'C',\n@@ -1862,8 +1823,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       'Commit root',\n     ]);\n \n-    // Flush passive effects.\n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       // B2's effect should not fire because it suspended\n       // 'Effect [B2]',\n       'Effect [Loading...]',\n@@ -1873,7 +1833,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       resolveText('B2');\n     });\n \n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       'B2',\n       'Destroy Layout Effect [Loading...]',\n       'Destroy Layout Effect [B]',\n@@ -1896,19 +1856,18 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     }\n \n     ReactNoop.render(<Foo />);\n-    expect(Scheduler).toFlushAndYield(['Foo']);\n+    await waitForAll(['Foo']);\n \n     React.startTransition(() => {\n       ReactNoop.render(<Foo renderContent={true} />);\n     });\n     Scheduler.unstable_advanceTime(100);\n     await advanceTimers(100);\n-    // Start rendering\n-    expect(Scheduler).toFlushAndYieldThrough(['Foo']);\n+    await waitFor(['Foo']);\n     // For some reason it took a long time to render Foo.\n     Scheduler.unstable_advanceTime(1250);\n     await advanceTimers(1250);\n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       // A suspends\n       'Suspend! [A]',\n       'Loading...',\n@@ -1919,24 +1878,19 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     // Flush some of the time\n     Scheduler.unstable_advanceTime(450);\n     await advanceTimers(450);\n-    // Because we've already been waiting for so long we can\n-    // wait a bit longer. Still nothing...\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n     // Eventually we'll show the fallback.\n     Scheduler.unstable_advanceTime(500);\n     await advanceTimers(500);\n-    // No need to rerender.\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n     // Since this is a transition, we never fallback.\n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n     // Flush the promise completely\n     await resolveText('A');\n-    // Renders successfully\n-    // TODO: Why does this render Foo\n-    expect(Scheduler).toFlushAndYield(['Foo', 'A']);\n+    await waitForAll(['Foo', 'A']);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"A\" />);\n   });\n \n@@ -1955,8 +1909,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     }\n \n     ReactNoop.render(<Foo />);\n-    // Start rendering\n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'Foo',\n       // A suspends\n       'Suspend! [A]',\n@@ -1972,8 +1925,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     Scheduler.unstable_advanceTime(5000);\n     await advanceTimers(5000);\n \n-    // Retry with the new content.\n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'A',\n       // B still suspends\n       'Suspend! [B]',\n@@ -1991,8 +1943,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Flush the last promise completely\n     await resolveText('B');\n-    // Renders successfully\n-    expect(Scheduler).toFlushAndYield(['B']);\n+    await waitForAll(['B']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -2016,8 +1967,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     }\n \n     ReactNoop.render(<Foo />);\n-    // Start rendering\n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'Foo',\n       // A suspends\n       'Suspend! [A]',\n@@ -2030,8 +1980,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     await resolveText('A');\n \n-    // Retry with the new content.\n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'A',\n       // B still suspends\n       'Suspend! [B]',\n@@ -2046,8 +1995,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     // Before we commit another Promise resolves.\n     // We're still showing the first loading state.\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"Loading...\" />);\n-    // Restart and render the complete content.\n-    expect(Scheduler).toFlushAndYield(['A', 'B']);\n+    await waitForAll(['A', 'B']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -2068,18 +2016,18 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     }\n \n     ReactNoop.render(<Foo />);\n-    expect(Scheduler).toFlushAndYield(['Foo']);\n+    await waitForAll(['Foo']);\n \n     React.startTransition(() => {\n       ReactNoop.render(<Foo renderContent={true} />);\n     });\n-    expect(Scheduler).toFlushAndYieldThrough(['Foo']);\n+    await waitFor(['Foo']);\n \n     // Advance some time.\n     Scheduler.unstable_advanceTime(100);\n     await advanceTimers(100);\n \n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       // A suspends\n       'Suspend! [A]',\n       'Loading...',\n@@ -2092,11 +2040,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     Scheduler.unstable_advanceTime(500);\n     jest.advanceTimersByTime(500);\n \n-    // We should have already shown the fallback.\n-    // When we wrote this test, we inferred the start time of high priority\n-    // updates as way earlier in the past. This test ensures that we don't\n-    // use this assumption to add a very long JND.\n-    expect(Scheduler).toFlushWithoutYielding();\n+    await waitForAll([]);\n     // Transitions never fallback.\n     expect(ReactNoop).toMatchRenderedOutput(null);\n   });\n@@ -2173,14 +2117,14 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       ReactNoop.render(<App />);\n     });\n \n-    expect(Scheduler).toHaveYielded(['Suspend! [A]']);\n+    assertLog(['Suspend! [A]']);\n     expect(ReactNoop).toMatchRenderedOutput('Loading...');\n \n     act(() => {\n       ReactNoop.flushSync(() => showB());\n     });\n \n-    expect(Scheduler).toHaveYielded(['Suspend! [A]', 'Suspend! [B]']);\n+    assertLog(['Suspend! [A]', 'Suspend! [B]']);\n   });\n \n   // TODO: flip to \"warns\" when this is implemented again.\n@@ -2236,7 +2180,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     // also make sure lowpriority is okay\n     await act(async () => show(true));\n \n-    expect(Scheduler).toHaveYielded(['Suspend! [A]']);\n+    assertLog(['Suspend! [A]']);\n     await resolveText('A');\n \n     expect(ReactNoop).toMatchRenderedOutput('Loading...');\n@@ -2262,7 +2206,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     // also make sure lowpriority is okay\n     await act(async () => _setShow(true));\n \n-    expect(Scheduler).toHaveYielded(['Suspend! [A]']);\n+    assertLog(['Suspend! [A]']);\n     await resolveText('A');\n \n     expect(ReactNoop).toMatchRenderedOutput('Loading...');\n@@ -2286,17 +2230,12 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     }\n \n     ReactNoop.render(<Foo />);\n-    expect(Scheduler).toFlushAndYield([\n-      'Foo',\n-      'Suspend! [A]',\n-      'B',\n-      'Initial load...',\n-    ]);\n+    await waitForAll(['Foo', 'Suspend! [A]', 'B', 'Initial load...']);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"Initial load...\" />);\n \n     // Eventually we resolve and show the data.\n     await resolveText('A');\n-    expect(Scheduler).toFlushAndYield(['A', 'B']);\n+    await waitForAll(['A', 'B']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -2306,13 +2245,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Update to show C\n     ReactNoop.render(<Foo showC={true} />);\n-    expect(Scheduler).toFlushAndYield([\n-      'Foo',\n-      'A',\n-      'Suspend! [C]',\n-      'Updating...',\n-      'B',\n-    ]);\n+    await waitForAll(['Foo', 'A', 'Suspend! [C]', 'Updating...', 'B']);\n     // Flush to skip suspended time.\n     Scheduler.unstable_advanceTime(600);\n     await advanceTimers(600);\n@@ -2328,7 +2261,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Later we load the data.\n     await resolveText('C');\n-    expect(Scheduler).toFlushAndYield(['A', 'C']);\n+    await waitForAll(['A', 'C']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -2354,7 +2287,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     }\n \n     ReactNoop.render(<Foo />);\n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'Foo',\n       'Suspend! [A]',\n       'B',\n@@ -2364,7 +2297,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Eventually we resolve and show the data.\n     await resolveText('A');\n-    expect(Scheduler).toFlushAndYield(['A']);\n+    await waitForAll(['A']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -2374,7 +2307,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Update to show C\n     ReactNoop.render(<Foo showC={true} />);\n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'Foo',\n       'A',\n       'Suspend! [C]',\n@@ -2393,7 +2326,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Later we load the data.\n     await resolveText('C');\n-    expect(Scheduler).toFlushAndYield(['A', 'C']);\n+    await waitForAll(['A', 'C']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -2422,12 +2355,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     }\n \n     ReactNoop.render(<Foo />);\n-    expect(Scheduler).toFlushAndYield([\n-      'Foo',\n-      'A',\n-      'Suspend! [B]',\n-      'Loading B...',\n-    ]);\n+    await waitForAll(['Foo', 'A', 'Suspend! [B]', 'Loading B...']);\n     // Flush to skip suspended time.\n     Scheduler.unstable_advanceTime(600);\n     await advanceTimers(600);\n@@ -2463,19 +2391,14 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     }\n \n     ReactNoop.render(<Foo />);\n-    expect(Scheduler).toFlushAndYield(['Foo', 'A']);\n+    await waitForAll(['Foo', 'A']);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"A\" />);\n \n     React.startTransition(() => {\n       ReactNoop.render(<Foo showB={true} />);\n     });\n \n-    expect(Scheduler).toFlushAndYield([\n-      'Foo',\n-      'A',\n-      'Suspend! [B]',\n-      'Loading B...',\n-    ]);\n+    await waitForAll(['Foo', 'A', 'Suspend! [B]', 'Loading B...']);\n     // Still suspended.\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"A\" />);\n \n@@ -2506,14 +2429,14 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     }\n \n     ReactNoop.render(<Foo />);\n-    expect(Scheduler).toFlushAndYield(['Foo', 'A']);\n+    await waitForAll(['Foo', 'A']);\n     expect(ReactNoop).toMatchRenderedOutput(<span prop=\"A\" />);\n \n     React.startTransition(() => {\n       ReactNoop.render(<Foo showB={true} />);\n     });\n \n-    expect(Scheduler).toFlushAndYield([\n+    await waitForAll([\n       'Foo',\n       'A',\n       'Suspend! [B]',\n@@ -2543,7 +2466,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     }\n \n     ReactNoop.render(<Foo />);\n-    expect(Scheduler).toFlushAndYield([]);\n+    await waitForAll([]);\n \n     ReactNoop.render(<Foo renderContent={1} />);\n \n@@ -2552,14 +2475,13 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     Scheduler.unstable_advanceTime(1500);\n     await advanceTimers(1500);\n \n-    expect(Scheduler).toFlushAndYield(['Suspend! [A]', 'Loading A...']);\n+    await waitForAll(['Suspend! [A]', 'Loading A...']);\n     // We're still suspended.\n     expect(ReactNoop).toMatchRenderedOutput(null);\n \n     // Schedule an update at idle pri.\n     ReactNoop.idleUpdates(() => ReactNoop.render(<Foo renderContent={2} />));\n-    // We won't even work on Idle priority.\n-    expect(Scheduler).toFlushAndYield([]);\n+    await waitForAll([]);\n \n     // We're still suspended.\n     expect(ReactNoop).toMatchRenderedOutput(null);\n@@ -2592,29 +2514,29 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       // Initial render.\n       React.startTransition(() => ReactNoop.render(<App page=\"A\" />));\n \n-      expect(Scheduler).toFlushAndYield(['Suspend! [A]', 'Loading...']);\n+      await waitForAll(['Suspend! [A]', 'Loading...']);\n       // Only a short time is needed to unsuspend the initial loading state.\n       Scheduler.unstable_advanceTime(400);\n       await advanceTimers(400);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"Loading...\" />);\n \n       // Later we load the data.\n       await resolveText('A');\n-      expect(Scheduler).toFlushAndYield(['A']);\n+      await waitForAll(['A']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"A\" />);\n \n       // Start transition.\n       React.startTransition(() => ReactNoop.render(<App page=\"B\" />));\n \n-      expect(Scheduler).toFlushAndYield(['Suspend! [B]', 'Loading...']);\n+      await waitForAll(['Suspend! [B]', 'Loading...']);\n       Scheduler.unstable_advanceTime(100000);\n       await advanceTimers(100000);\n       // Even after lots of time has passed, we have still not yet flushed the\n       // loading state.\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"A\" />);\n       // Later we load the data.\n       await resolveText('B');\n-      expect(Scheduler).toFlushAndYield(['B']);\n+      await waitForAll(['B']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"B\" />);\n     });\n \n@@ -2635,13 +2557,13 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       }\n \n       ReactNoop.render(<App />);\n-      expect(Scheduler).toFlushAndYield([]);\n+      await waitForAll([]);\n \n       // Initial render.\n       await act(async () => {\n         React.startTransition(() => transitionToPage('A'));\n \n-        expect(Scheduler).toFlushAndYield(['Suspend! [A]', 'Loading...']);\n+        await waitForAll(['Suspend! [A]', 'Loading...']);\n         // Only a short time is needed to unsuspend the initial loading state.\n         Scheduler.unstable_advanceTime(400);\n         await advanceTimers(400);\n@@ -2650,14 +2572,14 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n       // Later we load the data.\n       await resolveText('A');\n-      expect(Scheduler).toFlushAndYield(['A']);\n+      await waitForAll(['A']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"A\" />);\n \n       // Start transition.\n       await act(async () => {\n         React.startTransition(() => transitionToPage('B'));\n \n-        expect(Scheduler).toFlushAndYield(['Suspend! [B]', 'Loading...']);\n+        await waitForAll(['Suspend! [B]', 'Loading...']);\n         Scheduler.unstable_advanceTime(100000);\n         await advanceTimers(100000);\n         // Even after lots of time has passed, we have still not yet flushed the\n@@ -2666,7 +2588,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       });\n       // Later we load the data.\n       await resolveText('B');\n-      expect(Scheduler).toFlushAndYield(['B']);\n+      await waitForAll(['B']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"B\" />);\n     });\n \n@@ -2690,13 +2612,13 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       }\n \n       ReactNoop.render(<App />);\n-      expect(Scheduler).toFlushAndYield([]);\n+      await waitForAll([]);\n \n       // Initial render.\n       await act(async () => {\n         React.startTransition(() => transitionToPage('A'));\n \n-        expect(Scheduler).toFlushAndYield(['Suspend! [A]', 'Loading...']);\n+        await waitForAll(['Suspend! [A]', 'Loading...']);\n         // Only a short time is needed to unsuspend the initial loading state.\n         Scheduler.unstable_advanceTime(400);\n         await advanceTimers(400);\n@@ -2705,14 +2627,14 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n       // Later we load the data.\n       await resolveText('A');\n-      expect(Scheduler).toFlushAndYield(['A']);\n+      await waitForAll(['A']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"A\" />);\n \n       // Start transition.\n       await act(async () => {\n         React.startTransition(() => transitionToPage('B'));\n \n-        expect(Scheduler).toFlushAndYield(['Suspend! [B]', 'Loading...']);\n+        await waitForAll(['Suspend! [B]', 'Loading...']);\n         Scheduler.unstable_advanceTime(100000);\n         await advanceTimers(100000);\n         // Even after lots of time has passed, we have still not yet flushed the\n@@ -2721,7 +2643,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       });\n       // Later we load the data.\n       await resolveText('B');\n-      expect(Scheduler).toFlushAndYield(['B']);\n+      await waitForAll(['B']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"B\" />);\n     });\n   });\n@@ -2740,21 +2662,21 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       // Initial render.\n       React.startTransition(() => ReactNoop.render(<App page=\"A\" />));\n \n-      expect(Scheduler).toFlushAndYield(['Suspend! [A]', 'Loading...']);\n+      await waitForAll(['Suspend! [A]', 'Loading...']);\n       // Only a short time is needed to unsuspend the initial loading state.\n       Scheduler.unstable_advanceTime(400);\n       await advanceTimers(400);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"Loading...\" />);\n \n       // Later we load the data.\n       await resolveText('A');\n-      expect(Scheduler).toFlushAndYield(['A']);\n+      await waitForAll(['A']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"A\" />);\n \n       // Start transition.\n       React.startTransition(() => ReactNoop.render(<App page=\"B\" />));\n \n-      expect(Scheduler).toFlushAndYield(['Suspend! [B]', 'Loading...']);\n+      await waitForAll(['Suspend! [B]', 'Loading...']);\n       Scheduler.unstable_advanceTime(2999);\n       await advanceTimers(2999);\n       // Since the timeout is infinite (or effectively infinite),\n@@ -2763,12 +2685,12 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n       // Later we load the data.\n       await resolveText('B');\n-      expect(Scheduler).toFlushAndYield(['B']);\n+      await waitForAll(['B']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"B\" />);\n \n       // Start a long (infinite) transition.\n       React.startTransition(() => ReactNoop.render(<App page=\"C\" />));\n-      expect(Scheduler).toFlushAndYield(['Suspend! [C]', 'Loading...']);\n+      await waitForAll(['Suspend! [C]', 'Loading...']);\n \n       // Even after lots of time has passed, we have still not yet flushed the\n       // loading state.\n@@ -2794,13 +2716,13 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       }\n \n       ReactNoop.render(<App />);\n-      expect(Scheduler).toFlushAndYield([]);\n+      await waitForAll([]);\n \n       // Initial render.\n       await act(async () => {\n         React.startTransition(() => transitionToPage('A'));\n \n-        expect(Scheduler).toFlushAndYield(['Suspend! [A]', 'Loading...']);\n+        await waitForAll(['Suspend! [A]', 'Loading...']);\n         // Only a short time is needed to unsuspend the initial loading state.\n         Scheduler.unstable_advanceTime(400);\n         await advanceTimers(400);\n@@ -2809,14 +2731,14 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n       // Later we load the data.\n       await resolveText('A');\n-      expect(Scheduler).toFlushAndYield(['A']);\n+      await waitForAll(['A']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"A\" />);\n \n       // Start transition.\n       await act(async () => {\n         React.startTransition(() => transitionToPage('B'));\n \n-        expect(Scheduler).toFlushAndYield(['Suspend! [B]', 'Loading...']);\n+        await waitForAll(['Suspend! [B]', 'Loading...']);\n \n         Scheduler.unstable_advanceTime(2999);\n         await advanceTimers(2999);\n@@ -2827,14 +2749,14 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n       // Later we load the data.\n       await resolveText('B');\n-      expect(Scheduler).toFlushAndYield(['B']);\n+      await waitForAll(['B']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"B\" />);\n \n       // Start a long (infinite) transition.\n       await act(async () => {\n         React.startTransition(() => transitionToPage('C'));\n \n-        expect(Scheduler).toFlushAndYield(['Suspend! [C]', 'Loading...']);\n+        await waitForAll(['Suspend! [C]', 'Loading...']);\n \n         // Even after lots of time has passed, we have still not yet flushed the\n         // loading state.\n@@ -2864,13 +2786,13 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       }\n \n       ReactNoop.render(<App />);\n-      expect(Scheduler).toFlushAndYield([]);\n+      await waitForAll([]);\n \n       // Initial render.\n       await act(async () => {\n         React.startTransition(() => transitionToPage('A'));\n \n-        expect(Scheduler).toFlushAndYield(['Suspend! [A]', 'Loading...']);\n+        await waitForAll(['Suspend! [A]', 'Loading...']);\n         // Only a short time is needed to unsuspend the initial loading state.\n         Scheduler.unstable_advanceTime(400);\n         await advanceTimers(400);\n@@ -2879,14 +2801,14 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n       // Later we load the data.\n       await resolveText('A');\n-      expect(Scheduler).toFlushAndYield(['A']);\n+      await waitForAll(['A']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"A\" />);\n \n       // Start transition.\n       await act(async () => {\n         React.startTransition(() => transitionToPage('B'));\n \n-        expect(Scheduler).toFlushAndYield(['Suspend! [B]', 'Loading...']);\n+        await waitForAll(['Suspend! [B]', 'Loading...']);\n         Scheduler.unstable_advanceTime(2999);\n         await advanceTimers(2999);\n         // Since the timeout is infinite (or effectively infinite),\n@@ -2896,14 +2818,14 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n       // Later we load the data.\n       await resolveText('B');\n-      expect(Scheduler).toFlushAndYield(['B']);\n+      await waitForAll(['B']);\n       expect(ReactNoop).toMatchRenderedOutput(<span prop=\"B\" />);\n \n       // Start a long (infinite) transition.\n       await act(async () => {\n         React.startTransition(() => transitionToPage('C'));\n \n-        expect(Scheduler).toFlushAndYield(['Suspend! [C]', 'Loading...']);\n+        await waitForAll(['Suspend! [C]', 'Loading...']);\n \n         // Even after lots of time has passed, we have still not yet flushed the\n         // loading state.\n@@ -2931,9 +2853,9 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Initial render.\n     ReactNoop.render(<App page=\"A\" />);\n-    expect(Scheduler).toFlushAndYield(['Hi!', 'Suspend! [A]', 'Loading...']);\n+    await waitForAll(['Hi!', 'Suspend! [A]', 'Loading...']);\n     await resolveText('A');\n-    expect(Scheduler).toFlushAndYield(['Hi!', 'A']);\n+    await waitForAll(['Hi!', 'A']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"Hi!\" />\n@@ -2944,7 +2866,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     // Start transition.\n     React.startTransition(() => ReactNoop.render(<App page=\"B\" />));\n \n-    expect(Scheduler).toFlushAndYield(['Hi!', 'Suspend! [B]', 'Loading B...']);\n+    await waitForAll(['Hi!', 'Suspend! [B]', 'Loading B...']);\n \n     // Suspended\n     expect(ReactNoop).toMatchRenderedOutput(\n@@ -2955,7 +2877,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     );\n     Scheduler.unstable_advanceTime(1800);\n     await advanceTimers(1800);\n-    expect(Scheduler).toFlushAndYield([]);\n+    await waitForAll([]);\n     // We should still be suspended here because this loading state should be avoided.\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n@@ -2964,7 +2886,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       </>,\n     );\n     await resolveText('B');\n-    expect(Scheduler).toFlushAndYield(['Hi!', 'B']);\n+    await waitForAll(['Hi!', 'B']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"Hi!\" />\n@@ -2994,7 +2916,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Initial render.\n     ReactNoop.render(<App page=\"A\" />);\n-    expect(Scheduler).toFlushAndYield(['Hi!', 'A']);\n+    await waitForAll(['Hi!', 'A']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"Hi!\" />\n@@ -3005,7 +2927,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     // Start transition.\n     React.startTransition(() => ReactNoop.render(<App page=\"B\" />));\n \n-    expect(Scheduler).toFlushAndYield(['Hi!', 'Suspend! [B]', 'Loading B...']);\n+    await waitForAll(['Hi!', 'Suspend! [B]', 'Loading B...']);\n \n     // Suspended\n     expect(ReactNoop).toMatchRenderedOutput(\n@@ -3016,7 +2938,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     );\n     Scheduler.unstable_advanceTime(1800);\n     await advanceTimers(1800);\n-    expect(Scheduler).toFlushAndYield([]);\n+    await waitForAll([]);\n     // We should still be suspended here because this loading state should be avoided.\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n@@ -3025,7 +2947,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       </>,\n     );\n     await resolveText('B');\n-    expect(Scheduler).toFlushAndYield(['Hi!', 'B']);\n+    await waitForAll(['Hi!', 'B']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <span prop=\"Hi!\" />\n@@ -3051,13 +2973,13 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     await act(async () => {\n       root.render(<App text=\"Initial\" />);\n     });\n-    expect(Scheduler).toHaveYielded(['Suspend! [Initial]']);\n+    assertLog(['Suspend! [Initial]']);\n \n     // Resolve initial render\n     await act(async () => {\n       await resolveText('Initial');\n     });\n-    expect(Scheduler).toHaveYielded(['Initial']);\n+    assertLog(['Initial']);\n     expect(root).toMatchRenderedOutput(<span prop=\"Initial\" />);\n \n     await act(async () => {\n@@ -3066,7 +2988,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       React.startTransition(() => {\n         root.render(<App text=\"First update\" />);\n       });\n-      expect(Scheduler).toFlushAndYield(['Suspend! [First update]']);\n+      await waitForAll(['Suspend! [First update]']);\n \n       // Should not display a fallback\n       expect(root).toMatchRenderedOutput(<span prop=\"Initial\" />);\n@@ -3075,7 +2997,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       React.startTransition(() => {\n         root.render(<App text=\"Second update\" />);\n       });\n-      expect(Scheduler).toFlushAndYield(['Suspend! [Second update]']);\n+      await waitForAll(['Suspend! [Second update]']);\n \n       // Should not display a fallback\n       expect(root).toMatchRenderedOutput(<span prop=\"Initial\" />);\n@@ -3113,22 +3035,19 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       root.render(<App />);\n     });\n \n-    expect(Scheduler).toHaveYielded(['Foo']);\n+    assertLog(['Foo']);\n \n     await act(async () => {\n       foo.setState({suspend: true});\n \n-      // In the regression that this covers, we would neglect to reset the\n-      // current debug phase after suspending (in the catch block), so React\n-      // thinks we're still inside the render phase.\n-      expect(Scheduler).toFlushAndYieldThrough(['Suspend!']);\n+      await waitFor(['Suspend!']);\n \n       // Then when this setState happens, React would incorrectly fire a warning\n       // about updates that happen the render phase (only fired by classes).\n       foo.setState({suspend: false});\n     });\n \n-    expect(Scheduler).toHaveYielded([\n+    assertLog([\n       // First setState\n       'Foo',\n     ]);\n@@ -3159,24 +3078,24 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Initial render.\n     ReactNoop.render(<App showContent={false} />);\n-    expect(Scheduler).toFlushAndYieldThrough(['Commit']);\n+    await waitFor(['Commit']);\n     expect(ReactNoop).toMatchRenderedOutput(<div hidden={true} />);\n \n     // Start transition.\n     React.startTransition(() => {\n       ReactNoop.render(<App showContent={true} />);\n     });\n \n-    expect(Scheduler).toFlushAndYield(['Suspend! [A]', 'Loading...']);\n+    await waitForAll(['Suspend! [A]', 'Loading...']);\n     await resolveText('A');\n-    expect(Scheduler).toFlushAndYieldThrough(['A', 'Commit']);\n+    await waitFor(['A', 'Commit']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <div hidden={true} />\n         <span prop=\"A\" />\n       </>,\n     );\n-    expect(Scheduler).toFlushAndYield(['Offscreen']);\n+    await waitForAll(['Offscreen']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <div hidden={true}>Offscreen</div>\n@@ -3208,27 +3127,26 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n \n     // Initial render.\n     ReactNoop.render(<App showContent={false} />);\n-    expect(Scheduler).toFlushAndYieldThrough(['Commit']);\n+    await waitFor(['Commit']);\n     expect(ReactNoop).toMatchRenderedOutput(<div hidden={true} />);\n \n-    // Partially render through the hidden content.\n-    expect(Scheduler).toFlushAndYieldThrough(['Suspend! [A]']);\n+    await waitFor(['Suspend! [A]']);\n \n     // Start transition.\n     React.startTransition(() => {\n       ReactNoop.render(<App showContent={true} />);\n     });\n \n-    expect(Scheduler).toFlushAndYield(['Suspend! [A]', 'Loading...']);\n+    await waitForAll(['Suspend! [A]', 'Loading...']);\n     await resolveText('A');\n-    expect(Scheduler).toFlushAndYieldThrough(['A', 'Commit']);\n+    await waitFor(['A', 'Commit']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <div hidden={true} />\n         <span prop=\"A\" />\n       </>,\n     );\n-    expect(Scheduler).toFlushAndYield(['A', 'Offscreen']);\n+    await waitForAll(['A', 'Offscreen']);\n     expect(ReactNoop).toMatchRenderedOutput(\n       <>\n         <div hidden={true}>\n@@ -3269,7 +3187,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         root.render(<Parent />);\n       });\n-      expect(Scheduler).toHaveYielded(['A']);\n+      assertLog(['A']);\n       expect(root).toMatchRenderedOutput(<span prop=\"A\" />);\n \n       await act(async () => {\n@@ -3283,7 +3201,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         await resolveText('C');\n         setText('C');\n       });\n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         // First we attempt the high pri update. It suspends.\n         'Suspend! [B]',\n         'Loading...',\n@@ -3323,7 +3241,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         root.render(<Parent />);\n       });\n-      expect(Scheduler).toHaveYielded(['A']);\n+      assertLog(['A']);\n       expect(root).toMatchRenderedOutput(<span prop=\"A\" />);\n \n       await act(async () => {\n@@ -3337,7 +3255,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n           setText('C');\n         });\n \n-        expect(Scheduler).toFlushAndYield([\n+        await waitForAll([\n           // First we attempt the high pri update. It suspends.\n           'Suspend! [B]',\n           'Loading...',\n@@ -3352,8 +3270,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n           </>,\n         );\n \n-        // Now flush the remaining work. The Idle update successfully finishes.\n-        expect(Scheduler).toFlushAndYield(['C']);\n+        await waitForAll(['C']);\n         expect(root).toMatchRenderedOutput(<span prop=\"C\" />);\n       });\n     },\n@@ -3392,13 +3309,13 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         root.render(<App />);\n       });\n-      expect(Scheduler).toHaveYielded(['A']);\n+      assertLog(['A']);\n       expect(root).toMatchRenderedOutput(<span prop=\"A\" />);\n \n       await act(async () => {\n         // Schedule an update inside the Suspense boundary that suspends.\n         setAppText('B');\n-        expect(Scheduler).toFlushAndYield(['Suspend! [B]', 'Loading...']);\n+        await waitForAll(['Suspend! [B]', 'Loading...']);\n       });\n \n       expect(root).toMatchRenderedOutput(\n@@ -3418,7 +3335,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         });\n       });\n \n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         // First try to render the high pri update. Still suspended.\n         'Suspend! [C]',\n         'Loading...',\n@@ -3477,7 +3394,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         root.render(<Parent />);\n       });\n-      expect(Scheduler).toHaveYielded(['A']);\n+      assertLog(['A']);\n       // At this point, the setState return path follows current fiber.\n       expect(root).toMatchRenderedOutput(<span prop=\"A\" />);\n \n@@ -3486,15 +3403,15 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         setText('B');\n       });\n-      expect(Scheduler).toHaveYielded(['B']);\n+      assertLog(['B']);\n       // Now the setState return path follows the *alternate* fiber.\n       expect(root).toMatchRenderedOutput(<span prop=\"B\" />);\n \n       // Schedule another update. This time, we'll suspend.\n       await act(async () => {\n         setText('C');\n       });\n-      expect(Scheduler).toHaveYielded(['Suspend! [C]', 'Loading...']);\n+      assertLog(['Suspend! [C]', 'Loading...']);\n \n       // Commit. This will insert a fragment fiber to wrap around the component\n       // that triggered the update.\n@@ -3516,9 +3433,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         setText('D');\n       });\n-      // Even though the fragment fiber is not part of the return path, we should\n-      // be able to finish rendering.\n-      expect(Scheduler).toHaveYielded(['D']);\n+      assertLog(['D']);\n       expect(root).toMatchRenderedOutput(<span prop=\"D\" />);\n     },\n   );\n@@ -3554,7 +3469,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         root.render(<Parent />);\n       });\n-      expect(Scheduler).toHaveYielded(['A']);\n+      assertLog(['A']);\n       // At this point, the setState return path follows current fiber.\n       expect(root).toMatchRenderedOutput(<span prop=\"A\" />);\n \n@@ -3563,15 +3478,15 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         setText('B');\n       });\n-      expect(Scheduler).toHaveYielded(['B']);\n+      assertLog(['B']);\n       // Now the setState return path follows the *alternate* fiber.\n       expect(root).toMatchRenderedOutput(<span prop=\"B\" />);\n \n       // Schedule another update. This time, we'll suspend.\n       await act(async () => {\n         setText('C');\n       });\n-      expect(Scheduler).toHaveYielded(['Suspend! [C]', 'Loading...']);\n+      assertLog(['Suspend! [C]', 'Loading...']);\n \n       // Commit. This will insert a fragment fiber to wrap around the component\n       // that triggered the update.\n@@ -3598,9 +3513,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n           setText('E');\n         });\n       });\n-      // Even though the fragment fiber is not part of the return path, we should\n-      // be able to finish rendering.\n-      expect(Scheduler).toHaveYielded(['Suspend! [D]', 'E']);\n+      assertLog(['Suspend! [D]', 'E']);\n       expect(root).toMatchRenderedOutput(<span prop=\"E\" />);\n     },\n   );\n@@ -3663,7 +3576,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         root.render(<Parent step={0} />);\n       });\n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         'Outer text: A',\n         'Outer step: 0',\n         'Inner text: A',\n@@ -3683,7 +3596,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         setText('B');\n       });\n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         'Outer text: B',\n         'Outer step: 0',\n         'Suspend! [Inner text: B]',\n@@ -3709,10 +3622,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         });\n       });\n \n-      // Only the outer part can update. The inner part should still show a\n-      // fallback because we haven't finished loading B yet. Otherwise, the\n-      // inner text would be inconsistent with the outer text.\n-      expect(Scheduler).toHaveYielded([\n+      assertLog([\n         'Outer text: B',\n         'Outer step: 1',\n         'Suspend! [Inner text: B]',\n@@ -3733,11 +3643,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         await resolveText('Inner text: B');\n       });\n-      expect(Scheduler).toHaveYielded([\n-        'Inner text: B',\n-        'Inner step: 1',\n-        'Commit Child',\n-      ]);\n+      assertLog(['Inner text: B', 'Inner step: 1', 'Commit Child']);\n       expect(root).toMatchRenderedOutput(\n         <>\n           <span prop=\"Outer text: B\" />\n@@ -3802,7 +3708,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     await act(async () => {\n       root.render(<Parent step={0} />);\n     });\n-    expect(Scheduler).toHaveYielded(['Outer: A0', 'Inner: A0', 'Commit Child']);\n+    assertLog(['Outer: A0', 'Inner: A0', 'Commit Child']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         <span prop=\"Outer: A0\" />\n@@ -3814,11 +3720,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     await act(async () => {\n       setText('B');\n     });\n-    expect(Scheduler).toHaveYielded([\n-      'Outer: B0',\n-      'Suspend! [Inner: B0]',\n-      'Loading...',\n-    ]);\n+    assertLog(['Outer: B0', 'Suspend! [Inner: B0]', 'Loading...']);\n     // Commit the placeholder\n     await advanceTimers(250);\n     expect(root).toMatchRenderedOutput(\n@@ -3837,7 +3739,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       });\n     });\n \n-    expect(Scheduler).toHaveYielded(['Outer: B1', 'Inner: B1', 'Commit Child']);\n+    assertLog(['Outer: B1', 'Inner: B1', 'Commit Child']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         <span prop=\"Outer: B1\" />\n@@ -3895,20 +3797,15 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     await act(async () => {\n       root.render(<Root />);\n     });\n-    expect(Scheduler).toHaveYielded(['']);\n+    assertLog(['']);\n     expect(root).toMatchRenderedOutput(<span prop=\"\" />);\n \n     // Update to \"a\". That will suspend.\n     await act(async () => {\n       setTextWithShortTransition('a');\n-      expect(Scheduler).toFlushAndYield([\n-        'Pending...',\n-        '',\n-        'Suspend! [a]',\n-        'Loading...',\n-      ]);\n+      await waitForAll(['Pending...', '', 'Suspend! [a]', 'Loading...']);\n     });\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(root).toMatchRenderedOutput(\n       <>\n         <span prop=\"Pending...\" />\n@@ -3919,15 +3816,15 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     // Update to \"b\". That will suspend, too.\n     await act(async () => {\n       setTextWithLongTransition('b');\n-      expect(Scheduler).toFlushAndYield([\n+      await waitForAll([\n         // Neither is resolved yet.\n         'Pending...',\n         '',\n         'Suspend! [b]',\n         'Loading...',\n       ]);\n     });\n-    expect(Scheduler).toHaveYielded([]);\n+    assertLog([]);\n     expect(root).toMatchRenderedOutput(\n       <>\n         <span prop=\"Pending...\" />\n@@ -3939,7 +3836,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     await act(async () => {\n       await resolveText('a');\n \n-      expect(Scheduler).toFlushAndYield(['Suspend! [b]', 'Loading...']);\n+      await waitForAll(['Suspend! [b]', 'Loading...']);\n       expect(root).toMatchRenderedOutput(\n         <>\n           <span prop=\"Pending...\" />\n@@ -3951,7 +3848,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         await resolveText('b');\n       });\n-      expect(Scheduler).toHaveYielded(['b']);\n+      assertLog(['b']);\n       // The bug was that the pending state got stuck forever.\n       expect(root).toMatchRenderedOutput(<span prop=\"b\" />);\n     });\n@@ -3977,30 +3874,27 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         </Suspense>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['A']);\n+    assertLog(['A']);\n     expect(root).toMatchRenderedOutput(<span prop=\"A\" />);\n \n     await act(async () => {\n       setText('B');\n       ReactNoop.idleUpdates(() => {\n         setText('B');\n       });\n-      // Suspend the first update. The second update doesn't run because it has\n-      // Idle priority.\n-      expect(Scheduler).toFlushAndYield(['Suspend! [B]', 'Loading...']);\n+      await waitForAll(['Suspend! [B]', 'Loading...']);\n \n       // Commit the fallback. Now we'll try working on Idle.\n       jest.runAllTimers();\n \n-      // It also suspends.\n-      expect(Scheduler).toFlushAndYield(['Suspend! [B]']);\n+      await waitForAll(['Suspend! [B]']);\n     });\n \n     await act(async () => {\n       setText('B');\n       await resolveText('B');\n     });\n-    expect(Scheduler).toHaveYielded(['B']);\n+    assertLog(['B']);\n     expect(root).toMatchRenderedOutput(<span prop=\"B\" />);\n   });\n \n@@ -4026,7 +3920,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n         </>,\n       );\n     });\n-    expect(Scheduler).toHaveYielded(['A', 'Suspend! [Async]', 'Loading...']);\n+    assertLog(['A', 'Suspend! [Async]', 'Loading...']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         <span prop=\"A\" />\n@@ -4040,17 +3934,15 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       // Before the retry happens, schedule a new update.\n       setText('B');\n \n-      // The update should be allowed to finish before the retry is attempted.\n-      expect(Scheduler).toFlushUntilNextPaint(['B']);\n+      await waitForPaint(['B']);\n       expect(root).toMatchRenderedOutput(\n         <>\n           <span prop=\"B\" />\n           <span prop=\"Loading...\" />\n         </>,\n       );\n     });\n-    // Then do the retry.\n-    expect(Scheduler).toHaveYielded(['Async']);\n+    assertLog(['Async']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         <span prop=\"B\" />\n@@ -4087,13 +3979,13 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     await act(async () => {\n       root.render(<App show={false} />);\n     });\n-    expect(Scheduler).toHaveYielded(['Mount Child']);\n+    assertLog(['Mount Child']);\n     expect(root).toMatchRenderedOutput(<span prop=\"Child\" />);\n \n     await act(async () => {\n       root.render(<App show={true} />);\n     });\n-    expect(Scheduler).toHaveYielded(['Suspend! [Async]', 'Loading...']);\n+    assertLog(['Suspend! [Async]', 'Loading...']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         <span hidden={true} prop=\"Child\" />\n@@ -4104,7 +3996,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     await act(async () => {\n       root.render(null);\n     });\n-    expect(Scheduler).toHaveYielded(['Unmount Child']);\n+    assertLog(['Unmount Child']);\n   });\n \n   // @gate enableLegacyCache\n@@ -4135,13 +4027,13 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     await act(async () => {\n       root.render(<App show={false} />);\n     });\n-    expect(Scheduler).toHaveYielded(['Mount Child']);\n+    assertLog(['Mount Child']);\n     expect(root).toMatchRenderedOutput(<span prop=\"Child\" />);\n \n     await act(async () => {\n       root.render(<App show={true} />);\n     });\n-    expect(Scheduler).toHaveYielded(['Suspend! [Async]', 'Loading...']);\n+    assertLog(['Suspend! [Async]', 'Loading...']);\n     expect(root).toMatchRenderedOutput(\n       <>\n         <span hidden={true} prop=\"Child\" />\n@@ -4152,7 +4044,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n     await act(async () => {\n       root.render(null);\n     });\n-    expect(Scheduler).toHaveYielded(['Unmount Child']);\n+    assertLog(['Unmount Child']);\n   });\n \n   // @gate enableLegacyCache\n@@ -4202,7 +4094,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         root.render(<App showMore={false} />);\n       });\n-      expect(Scheduler).toHaveYielded([]);\n+      assertLog([]);\n       expect(root).toMatchRenderedOutput(<div />);\n \n       // Update. This will cause two separate trees to suspend. The first tree\n@@ -4221,7 +4113,7 @@ describe('ReactSuspenseWithNoopRenderer', () => {\n       await act(async () => {\n         root.render(<App showMore={true} />);\n       });\n-      expect(Scheduler).toHaveYielded(['Suspend! [Async]', 'Loading...', 'Hi']);\n+      assertLog(['Suspend! [Async]', 'Loading...', 'Hi']);\n       expect(root).toMatchRenderedOutput(\n         <div>\n           <span prop=\"Loading...\" />",
  },
];
